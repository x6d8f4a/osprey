"""Artifact System - Unified artifact management for UI display.

This module provides a unified abstraction for all types of artifacts that can be
generated by capabilities and displayed in UI interfaces (TUI, OpenWebUI, etc.).

**Artifact Types:**

- **image**: Figures, plots, visualizations (PNG, JPG, SVG)
- **notebook**: Jupyter notebooks with execution results
- **command**: Launchable URIs (web apps, desktop apps, viewers)
- **html**: Interactive HTML content (Bokeh, Plotly dashboards)
- **file**: Generic downloadable files

**Architecture:**

The artifact system provides a single registration point (`StateManager.register_artifact`)
that replaces the previous separate methods for figures, commands, and notebooks. Each
artifact has a unique ID, type, and type-specific data payload, enabling unified tracking
and "new" artifact detection across conversation turns.

**Migration:**

The old `ui_captured_figures`, `ui_launchable_commands`, and `ui_captured_notebooks`
fields are maintained for backward compatibility but will be deprecated. New code
should use `ui_artifacts` exclusively.

.. seealso::
   :class:`osprey.state.StateManager` : Registration methods for artifacts
   :class:`osprey.state.AgentState` : State structure containing ui_artifacts
"""

from enum import StrEnum
from typing import Any, TypedDict


class ArtifactType(StrEnum):
    """Enumeration of supported artifact types.

    Each artifact type corresponds to a specific category of generated content
    that can be displayed in UI interfaces. The type determines how the artifact
    is rendered and what actions are available.

    Attributes:
        IMAGE: Static images and visualizations (PNG, JPG, SVG)
        NOTEBOOK: Jupyter notebooks with execution results
        COMMAND: Launchable URIs for external applications
        HTML: Interactive HTML content (dashboards, widgets)
        FILE: Generic downloadable files
    """

    IMAGE = "image"
    NOTEBOOK = "notebook"
    COMMAND = "command"
    HTML = "html"
    FILE = "file"


class ImageArtifactData(TypedDict, total=False):
    """Data payload for image artifacts.

    Attributes:
        path: Absolute path to the image file
        format: Image format (png, jpg, svg, etc.)
        width: Optional width in pixels
        height: Optional height in pixels
    """

    path: str
    format: str
    width: int
    height: int


class NotebookArtifactData(TypedDict, total=False):
    """Data payload for notebook artifacts.

    Attributes:
        path: Path to the notebook file (.ipynb)
        url: URL to access the notebook (e.g., Jupyter server)
    """

    path: str
    url: str


class CommandArtifactData(TypedDict, total=False):
    """Data payload for command/URI artifacts.

    Attributes:
        uri: Launchable URI (http://, file://, custom://)
        command_type: Type of command (web_app, desktop_app, viewer, etc.)
    """

    uri: str
    command_type: str


class HTMLArtifactData(TypedDict, total=False):
    """Data payload for interactive HTML artifacts.

    Attributes:
        path: Path to the HTML file
        url: URL to access the content
        framework: Framework used (bokeh, plotly, custom, etc.)
    """

    path: str
    url: str
    framework: str


class FileArtifactData(TypedDict, total=False):
    """Data payload for generic file artifacts.

    Attributes:
        path: Absolute path to the file
        mime_type: MIME type of the file
        size_bytes: File size in bytes
    """

    path: str
    mime_type: str
    size_bytes: int


# Union type for all artifact data payloads
ArtifactData = (
    ImageArtifactData
    | NotebookArtifactData
    | CommandArtifactData
    | HTMLArtifactData
    | FileArtifactData
)


class Artifact(TypedDict, total=False):
    """Unified artifact structure for all artifact types.

    This TypedDict defines the common structure for all artifacts stored in
    the `ui_artifacts` state field. Each artifact has a unique ID, type,
    source capability, and type-specific data payload.

    Required Attributes:
        id: Unique identifier (UUID) for the artifact
        type: Artifact type from ArtifactType enum
        capability: Name of the capability that generated this artifact
        created_at: ISO format timestamp of creation

    Optional Attributes:
        display_name: Human-readable name for the artifact
        data: Type-specific data payload (path, url, etc.)
        metadata: Additional capability-specific metadata

    Examples:
        Image artifact::

            {
                "id": "550e8400-e29b-41d4-a716-446655440000",
                "type": "image",
                "capability": "python_executor",
                "created_at": "2024-01-15T10:30:00",
                "display_name": "Analysis Plot",
                "data": {"path": "/path/to/plot.png", "format": "png"},
                "metadata": {"execution_folder": "/path/to/exec"}
            }

        Notebook artifact::

            {
                "id": "550e8400-e29b-41d4-a716-446655440001",
                "type": "notebook",
                "capability": "python_executor",
                "created_at": "2024-01-15T10:30:00",
                "display_name": "Execution Notebook",
                "data": {"path": "/path/to/notebook.ipynb", "url": "http://jupyter/..."}
            }
    """

    # Required fields
    id: str
    type: str  # ArtifactType value
    capability: str
    created_at: str

    # Optional fields
    display_name: str
    data: dict[str, Any]  # Type-specific payload
    metadata: dict[str, Any]  # Additional metadata


def create_artifact(
    artifact_type: ArtifactType,
    capability: str,
    data: dict[str, Any],
    display_name: str | None = None,
    metadata: dict[str, Any] | None = None,
) -> Artifact:
    """Create a new artifact with a unique ID and timestamp.

    This is the factory function for creating properly structured artifacts.
    It generates a unique ID and timestamp, and validates the artifact type.

    Args:
        artifact_type: Type of artifact from ArtifactType enum
        capability: Name of the capability generating this artifact
        data: Type-specific data payload (path, url, etc.)
        display_name: Optional human-readable name
        metadata: Optional additional metadata

    Returns:
        Artifact: Properly structured artifact dictionary

    Examples:
        Create an image artifact::

            >>> artifact = create_artifact(
            ...     ArtifactType.IMAGE,
            ...     "python_executor",
            ...     {"path": "/path/to/plot.png", "format": "png"},
            ...     display_name="Analysis Plot"
            ... )
            >>> artifact["type"]
            'image'
            >>> "id" in artifact
            True
    """
    import uuid
    from datetime import datetime

    artifact: Artifact = {
        "id": str(uuid.uuid4()),
        "type": artifact_type.value,
        "capability": capability,
        "created_at": datetime.now().isoformat(),
        "data": data,
    }

    if display_name:
        artifact["display_name"] = display_name

    if metadata:
        artifact["metadata"] = metadata

    return artifact


def get_artifact_type_icon(artifact_type: ArtifactType | str) -> str:
    """Get the display icon for an artifact type.

    Args:
        artifact_type: Artifact type enum or string value

    Returns:
        Unicode icon character for the artifact type
    """
    if isinstance(artifact_type, str):
        artifact_type = ArtifactType(artifact_type)

    icons = {
        ArtifactType.IMAGE: "\u25eb",  # ◫ half-filled square
        ArtifactType.NOTEBOOK: "\u2261",  # ≡ triple bar
        ArtifactType.COMMAND: "\u25c7",  # ◇ open diamond
        ArtifactType.HTML: "\u25c7",  # ◇ open diamond
        ArtifactType.FILE: "\u25a1",  # □ open square
    }
    return icons.get(artifact_type, "\u00b7")


def validate_artifact_data(artifact_type: ArtifactType, data: dict[str, Any]) -> bool:
    """Validate that artifact data contains required fields for its type.

    Args:
        artifact_type: Type of artifact to validate
        data: Data payload to validate

    Returns:
        True if data is valid for the artifact type, False otherwise
    """
    required_fields: dict[ArtifactType, list[str]] = {
        ArtifactType.IMAGE: ["path"],
        ArtifactType.NOTEBOOK: [],  # Either path or url is acceptable
        ArtifactType.COMMAND: ["uri"],
        ArtifactType.HTML: [],  # Either path or url is acceptable
        ArtifactType.FILE: ["path"],
    }

    required = required_fields.get(artifact_type, [])
    return all(field in data for field in required)


def populate_legacy_fields_from_artifacts(
    artifacts: list[Artifact],
) -> dict[str, Any]:
    """Populate legacy UI fields from the unified artifacts list.

    This function derives the legacy `ui_captured_figures`, `ui_launchable_commands`,
    and `ui_captured_notebooks` fields from the canonical `ui_artifacts` list.
    This ensures backward compatibility with interfaces that rely on the old fields
    (e.g., OpenWebUI pipeline) while allowing capabilities to use the new unified API.

    Args:
        artifacts: List of artifacts from ui_artifacts state field

    Returns:
        Dictionary with legacy field updates:
        - ui_captured_figures: List of figure entries for IMAGE artifacts
        - ui_launchable_commands: List of command entries for COMMAND artifacts
        - ui_captured_notebooks: List of notebook URLs for NOTEBOOK artifacts

    Example:
        >>> artifacts = [
        ...     {"type": "image", "capability": "python", "data": {"path": "/fig.png"}},
        ...     {"type": "notebook", "capability": "python", "data": {"url": "http://..."}},
        ... ]
        >>> legacy = populate_legacy_fields_from_artifacts(artifacts)
        >>> len(legacy["ui_captured_figures"])
        1
        >>> len(legacy["ui_captured_notebooks"])
        1
    """
    figures: list[dict[str, Any]] = []
    commands: list[dict[str, Any]] = []
    notebooks: list[str] = []

    for artifact in artifacts:
        artifact_type = artifact.get("type", "")
        data = artifact.get("data", {})
        capability = artifact.get("capability", "")
        created_at = artifact.get("created_at", "")
        display_name = artifact.get("display_name")
        metadata = artifact.get("metadata")

        if artifact_type == ArtifactType.IMAGE.value:
            # Convert to legacy figure entry
            figure_entry: dict[str, Any] = {
                "capability": capability,
                "figure_path": data.get("path", ""),
                "created_at": created_at,
            }
            if display_name:
                figure_entry["display_name"] = display_name
            if metadata:
                figure_entry["metadata"] = metadata
            figures.append(figure_entry)

        elif artifact_type == ArtifactType.COMMAND.value:
            # Convert to legacy command entry
            command_entry: dict[str, Any] = {
                "capability": capability,
                "uri": data.get("uri", ""),
                "created_at": created_at,
            }
            if display_name:
                command_entry["display_name"] = display_name
            if metadata:
                command_entry["metadata"] = metadata
            commands.append(command_entry)

        elif artifact_type == ArtifactType.NOTEBOOK.value:
            # Legacy notebooks field is just a list of URLs
            url = data.get("url", "")
            if url:
                notebooks.append(url)

    return {
        "ui_captured_figures": figures,
        "ui_launchable_commands": commands,
        "ui_captured_notebooks": notebooks,
    }
