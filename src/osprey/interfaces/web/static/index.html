<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Osprey Debug</title>
    <style>
        * { box-sizing: border-box; margin: 0; padding: 0; }

        /* Theme variables */
        :root {
            --bg: #fff;
            --bg-alt: #f9f9f9;
            --text: #333;
            --text-muted: #666;
            --text-faint: #999;
            --border: #ddd;
            --btn-bg: #f5f5f5;
            --btn-hover: #eee;
        }
        body.dark {
            --bg: #1a1a1a;
            --bg-alt: #252525;
            --text: #e0e0e0;
            --text-muted: #aaa;
            --text-faint: #777;
            --border: #444;
            --btn-bg: #333;
            --btn-hover: #444;
        }

        body {
            font-family: monospace;
            font-size: 13px;
            line-height: 1.4;
            background: var(--bg);
            color: var(--text);
            height: 100vh;
            display: flex;
            flex-direction: column;
        }

        /* Header bar */
        .header {
            padding: 8px 12px;
            border-bottom: 1px solid var(--border);
            display: flex;
            align-items: center;
            gap: 16px;
            flex-wrap: wrap;
        }
        .header h1 { font-size: 14px; font-weight: bold; }
        .status { display: flex; align-items: center; gap: 6px; }
        .status-dot {
            width: 8px; height: 8px;
            border-radius: 50%;
            background: var(--text-faint);
        }
        .status-dot.connected { background: #090; }
        .status-dot.connecting { background: #f90; }
        .status-dot.streaming { background: #090; }
        @keyframes breathing {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.4; }
        }
        .status-dot.breathing {
            animation: breathing 1.5s ease-in-out infinite;
        }
        .theme-toggle {
            margin-left: auto;
            padding: 4px 8px;
            font-size: 11px;
        }

        /* Controls row */
        .controls {
            padding: 8px 12px;
            border-bottom: 1px solid var(--border);
            display: flex;
            gap: 8px;
            flex-wrap: wrap;
            align-items: center;
        }
        .query-input {
            flex: 1;
            min-width: 200px;
            padding: 6px 8px;
            border: 1px solid var(--border);
            background: var(--bg);
            color: var(--text);
            font-family: inherit;
            font-size: inherit;
        }
        .query-input:focus { outline: 1px solid var(--text-muted); }
        button {
            padding: 6px 12px;
            border: 1px solid var(--border);
            background: var(--btn-bg);
            color: var(--text);
            font-family: inherit;
            font-size: inherit;
            cursor: pointer;
        }
        button:hover { background: var(--btn-hover); }
        button:disabled { opacity: 0.5; cursor: not-allowed; }

        /* Search and filters */
        .filters {
            padding: 8px 12px;
            border-bottom: 1px solid var(--border);
            display: flex;
            gap: 12px;
            flex-wrap: wrap;
            align-items: center;
        }
        .search-input {
            flex: 1;
            min-width: 150px;
            padding: 4px 8px;
            border: 1px solid var(--border);
            background: var(--bg);
            color: var(--text);
            font-family: inherit;
            font-size: inherit;
        }
        .filter-group {
            display: flex;
            gap: 8px;
            align-items: center;
        }
        .filter-group label { font-size: 12px; color: var(--text-muted); }
        .filter-group select {
            padding: 4px;
            border: 1px solid var(--border);
            background: var(--bg);
            color: var(--text);
            font-family: inherit;
            font-size: 12px;
        }

        /* Event timeline */
        .timeline {
            flex: 1;
            overflow-y: auto;
            padding: 8px 12px;
        }
        .event {
            border: 1px solid transparent;
            margin-bottom: 4px;
        }
        .event:hover, .event.expanded {
            border-color: var(--border);
        }
        .event-row {
            display: flex;
            gap: 8px;
            padding: 4px 8px;
            cursor: pointer;
            align-items: baseline;
        }
        .event-row:hover { background: var(--bg-alt); }
        .event-tag {
            font-size: 11px;
            padding: 1px 4px;
            border: 1px solid var(--text-faint);
            white-space: nowrap;
        }
        .event-component {
            color: var(--text-muted);
            padding: 1px 4px;
            border-radius: 2px;
        }
        .event-msg { flex: 1; overflow: hidden; text-overflow: ellipsis; white-space: nowrap; }
        .event-time { color: var(--text-faint); font-size: 11px; }
        .event-details {
            display: none;
            padding: 8px;
            border-top: 1px solid var(--border);
            background: var(--bg-alt);
        }
        .event.expanded .event-details { display: block; }
        .event-details pre {
            white-space: pre-wrap;
            word-break: break-all;
            font-size: 12px;
        }
        .details-actions {
            margin-bottom: 8px;
            display: flex;
            gap: 8px;
        }

        /* Streaming response area */
        .streaming-response {
            padding: 12px;
            border-top: 1px solid var(--border);
            background: var(--bg-alt);
            display: none;
        }
        .streaming-response.active {
            display: block;
        }
        .streaming-response-header {
            font-weight: bold;
            margin-bottom: 8px;
            color: var(--text-muted);
            display: flex;
            align-items: center;
            gap: 8px;
        }
        .streaming-indicator {
            width: 8px;
            height: 8px;
            background: #090;
            border-radius: 50%;
            animation: breathing 1s ease-in-out infinite;
        }
        .streaming-response.complete .streaming-indicator {
            animation: none;
        }
        .streaming-response-content {
            white-space: pre-wrap;
            word-break: break-word;
            font-family: inherit;
            line-height: 1.5;
        }

        /* Grouped token events */
        .event-group {
            margin-bottom: 4px;
        }
        .event-parent {
            cursor: pointer;
        }
        .event-parent .toggle-icon {
            display: inline-block;
            width: 12px;
            transition: transform 0.15s;
        }
        .event-parent.expanded .toggle-icon {
            transform: rotate(90deg);
        }
        .event-children {
            display: none;
            margin-left: 20px;
            border-left: 2px solid var(--border);
            padding-left: 8px;
        }
        .event-parent.expanded + .event-children {
            display: block;
        }
        .event-child {
            padding: 2px 8px;
            font-size: 12px;
            color: var(--text-muted);
            border-bottom: 1px solid var(--border);
        }
        .event-child:last-child {
            border-bottom: none;
        }
        .event-child .token-content {
            font-family: monospace;
            background: var(--bg-alt);
            padding: 1px 4px;
            border-radius: 2px;
        }
        .event-child .token-time {
            float: right;
            font-size: 11px;
            color: var(--text-faint);
        }

        /* Footer stats */
        .footer {
            padding: 6px 12px;
            border-top: 1px solid var(--border);
            font-size: 12px;
            color: var(--text-muted);
            display: flex;
            gap: 16px;
        }

        /* Tooltip */
        .tooltip {
            position: fixed;
            z-index: 1000;
            padding: 8px 12px;
            background: var(--bg-alt);
            border: 1px solid var(--border);
            box-shadow: 0 2px 8px rgba(0,0,0,0.15);
            font-size: 12px;
            max-width: 400px;
            pointer-events: none;
            display: none;
        }
        .tooltip.visible { display: block; }
        .tooltip-header {
            font-weight: bold;
            margin-bottom: 4px;
            padding-bottom: 4px;
            border-bottom: 1px solid var(--border);
        }
        .tooltip-row {
            display: flex;
            gap: 8px;
            margin: 2px 0;
            align-items: flex-start;
        }
        .tooltip-label { color: var(--text-muted); min-width: 80px; flex-shrink: 0; }
        .tooltip-value {
            color: var(--text);
            word-break: break-word;
            max-width: 280px;
            overflow-wrap: break-word;
        }
        .tooltip-separator {
            border-top: 1px solid var(--border);
            margin: 4px 0;
        }

        /* Special status event styling */
        .event.status-success { border: 1px solid var(--status-success-color, #090); }
        .event.status-warning { border: 1px solid var(--status-warning-color, #f90); }
        .event.status-error { border: 1px solid var(--status-error-color, #c00); }
        .event.status-key-info { background: rgba(255, 255, 0, 0.15); border-color: var(--border); }
    </style>
</head>
<body>
    <div class="header">
        <h1>Osprey Debug</h1>
        <div class="status">
            <div class="status-dot connecting breathing" id="statusDot"></div>
            <span id="statusText">Connecting...</span>
        </div>
        <button class="theme-toggle" id="themeToggle">Dark</button>
    </div>

    <div class="controls">
        <input type="text" class="query-input" id="queryInput"
               placeholder="Enter query..." value="What's the weather in San Francisco?">
        <button id="executeBtn" disabled>Execute</button>
        <button id="clearBtn">Clear</button>
        <button id="exportBtn">Export YAML</button>
    </div>

    <div class="filters">
        <input type="text" class="search-input" id="searchInput" placeholder="Search events...">
        <div class="filter-group">
            <label>Type:</label>
            <select id="typeFilter"><option value="">All</option></select>
        </div>
        <div class="filter-group">
            <label>Component:</label>
            <select id="componentFilter"><option value="">All</option></select>
        </div>
        <button id="resetFiltersBtn">Reset</button>
    </div>

    <div class="timeline" id="timeline">
        <!-- Events appended here (latest at bottom) -->
    </div>

    <div class="streaming-response" id="streamingResponse">
        <div class="streaming-response-header">
            <div class="streaming-indicator"></div>
            <span>Response</span>
        </div>
        <div class="streaming-response-content" id="streamingContent"></div>
    </div>

    <div class="footer">
        <span>Events: <strong id="eventCount">0</strong></span>
        <span>Filtered: <strong id="filteredCount">0</strong></span>
    </div>

    <div class="tooltip" id="tooltip"></div>

    <script>
        // State
        let ws = null;
        let events = [];
        let searchText = '';
        let typeFilter = '';
        let componentFilter = '';
        let componentColors = {};
        let colorPalette = {};  // Server-provided Rich color hex palette
        let colorsReady = false;
        let wsReady = false;

        // DOM
        const statusDot = document.getElementById('statusDot');
        const statusText = document.getElementById('statusText');
        const queryInput = document.getElementById('queryInput');
        const executeBtn = document.getElementById('executeBtn');
        const clearBtn = document.getElementById('clearBtn');
        const exportBtn = document.getElementById('exportBtn');
        const searchInput = document.getElementById('searchInput');
        const typeFilterEl = document.getElementById('typeFilter');
        const componentFilterEl = document.getElementById('componentFilter');
        const timeline = document.getElementById('timeline');
        const eventCount = document.getElementById('eventCount');
        const filteredCount = document.getElementById('filteredCount');
        const themeToggle = document.getElementById('themeToggle');
        const resetFiltersBtn = document.getElementById('resetFiltersBtn');
        const tooltip = document.getElementById('tooltip');
        const streamingResponse = document.getElementById('streamingResponse');
        const streamingContent = document.getElementById('streamingContent');
        let tooltipTimeout = null;

        // Streaming session state for grouped token display
        let currentStreamingSession = null;  // {parentEl, childrenEl, tokens: [], startTime, nodeName}

        // Theme toggle
        function initTheme() {
            const savedTheme = localStorage.getItem('osprey-theme');
            if (savedTheme === 'dark') {
                document.body.classList.add('dark');
                themeToggle.textContent = 'Light';
            }
        }
        themeToggle.onclick = () => {
            document.body.classList.toggle('dark');
            const isDark = document.body.classList.contains('dark');
            themeToggle.textContent = isDark ? 'Light' : 'Dark';
            localStorage.setItem('osprey-theme', isDark ? 'dark' : 'light');
            updateEventColors();
        };
        initTheme();

        // Update component colors when theme changes (always use font color)
        function updateEventColors() {
            document.querySelectorAll('.event-component').forEach(el => {
                const color = el.dataset.color;
                if (color) {
                    el.style.backgroundColor = 'transparent';
                    el.style.color = color;
                }
            });
        }

        // Check if fully ready (colors + WebSocket)
        function checkReady() {
            if (colorsReady && wsReady) {
                statusDot.classList.remove('connecting', 'breathing');
                statusDot.classList.add('connected');
                statusText.textContent = 'Ready';
                executeBtn.disabled = false;
            }
        }

        // Fetch component colors and palette from server
        async function fetchColors() {
            try {
                const res = await fetch('/api/colors');
                const data = await res.json();
                componentColors = data.colors || {};
                colorPalette = data.palette || {};
            } catch (e) {
                componentColors = {};
                colorPalette = {};
            }
            colorsReady = true;
            checkReady();
        }

        // Get CSS color for a component using server-provided Rich palette
        function getComponentColor(component) {
            if (!component) return null;
            const colorName = componentColors[component];
            if (!colorName) return null;
            // Use server-provided palette for accurate Rich colors, or use name as-is if it's already hex
            return colorPalette[colorName] || colorName;
        }

        // Connect to WebSocket
        function connect() {
            const protocol = location.protocol === 'https:' ? 'wss:' : 'ws:';
            ws = new WebSocket(`${protocol}//${location.host}/ws/events`);

            ws.onopen = () => {
                wsReady = true;
                if (!colorsReady) {
                    statusText.textContent = 'Initializing...';
                }
                checkReady();
            };
            ws.onclose = () => {
                wsReady = false;
                statusDot.classList.remove('connected', 'connecting', 'streaming', 'breathing');
                statusText.textContent = 'Disconnected';
                executeBtn.disabled = true;
                // Restart connection with connecting state
                setTimeout(() => {
                    statusDot.classList.add('connecting', 'breathing');
                    statusText.textContent = 'Connecting...';
                    connect();
                }, 3000);
            };
            ws.onmessage = (e) => handleEvent(JSON.parse(e.data));
        }

        // Handle event
        function handleEvent(data) {
            events.push(data);
            eventCount.textContent = events.length;
            updateFilterOptions();

            if (data.type === 'execution_started') {
                statusDot.classList.remove('connecting');
                statusDot.classList.add('streaming');
                statusText.textContent = 'Streaming...';
                // Reset streaming response area for new execution
                streamingResponse.classList.remove('active', 'complete');
                streamingContent.textContent = '';
                // Reset streaming session for grouped display
                currentStreamingSession = null;
            } else if (data.type === 'execution_completed' || data.type === 'execution_error') {
                statusDot.classList.remove('streaming', 'breathing');
                statusDot.classList.add('connected');
                statusText.textContent = 'Ready';
                // Mark streaming as complete
                if (streamingResponse.classList.contains('active')) {
                    streamingResponse.classList.add('complete');
                }
                // Finalize streaming session group
                if (currentStreamingSession) {
                    finalizeStreamingSession();
                }
            } else if (data.type === 'streaming_token') {
                // Update streaming response viewer with accumulated content
                streamingResponse.classList.add('active');
                streamingContent.textContent = data.accumulated_response || '';
                // Add to grouped token display in timeline
                handleStreamingToken(data);
                return; // Don't add as individual event
            }

            if (matchesFilters(data)) {
                appendEvent(data);
                timeline.scrollTop = timeline.scrollHeight;
            }
            updateFilteredCount();
        }

        // Handle streaming token for grouped display
        function handleStreamingToken(data) {
            const time = new Date(data.timestamp);

            // Create new session on first token
            if (!currentStreamingSession) {
                currentStreamingSession = {
                    tokens: [],
                    startTime: time,
                    nodeName: data.node_name || 'respond',
                    parentEl: null,
                    childrenEl: null
                };
                // Create parent event group in timeline
                createStreamingGroup(data);
            }

            // Add token to session
            currentStreamingSession.tokens.push({
                content: data.token,
                index: data.token_index,
                time: time
            });

            // Add child token row
            addTokenChild(data);

            // Update parent summary
            updateStreamingGroupSummary();
        }

        // Create the parent streaming group element
        function createStreamingGroup(data) {
            const group = document.createElement('div');
            group.className = 'event-group';
            group.innerHTML = `
                <div class="event event-parent">
                    <div class="event-row">
                        <span class="toggle-icon">▶</span>
                        <span class="event-tag">LLM Streaming</span>
                        <span class="event-component" style="color: ${getComponentColor(data.node_name) || 'inherit'}">[${data.node_name || 'respond'}]</span>
                        <span class="event-msg streaming-summary">Streaming...</span>
                        <span class="event-time">${new Date(data.timestamp).toLocaleTimeString()}</span>
                    </div>
                </div>
                <div class="event-children"></div>
            `;

            const parentEl = group.querySelector('.event-parent');
            const childrenEl = group.querySelector('.event-children');

            parentEl.onclick = () => parentEl.classList.toggle('expanded');

            currentStreamingSession.parentEl = parentEl;
            currentStreamingSession.childrenEl = childrenEl;

            timeline.appendChild(group);
            timeline.scrollTop = timeline.scrollHeight;
        }

        // Add a token as child row
        function addTokenChild(data) {
            if (!currentStreamingSession || !currentStreamingSession.childrenEl) return;

            const child = document.createElement('div');
            child.className = 'event-child';
            const displayToken = escapeHtml(data.token).replace(/\n/g, '↵').replace(/ /g, '·');
            child.innerHTML = `
                <span class="token-time">${new Date(data.timestamp).toLocaleTimeString('en-US', {hour12: false, hour: '2-digit', minute: '2-digit', second: '2-digit', fractionalSecondDigits: 3})}</span>
                Token ${data.token_index}: <span class="token-content">${displayToken}</span>
            `;
            currentStreamingSession.childrenEl.appendChild(child);
        }

        // Update parent summary with current stats
        function updateStreamingGroupSummary() {
            if (!currentStreamingSession || !currentStreamingSession.parentEl) return;

            const summary = currentStreamingSession.parentEl.querySelector('.streaming-summary');
            if (summary) {
                summary.textContent = `${currentStreamingSession.tokens.length} tokens...`;
            }
        }

        // Finalize streaming session with duration
        function finalizeStreamingSession() {
            if (!currentStreamingSession || !currentStreamingSession.parentEl) return;

            const endTime = new Date();
            const duration = ((endTime - currentStreamingSession.startTime) / 1000).toFixed(2);
            const tokenCount = currentStreamingSession.tokens.length;

            const summary = currentStreamingSession.parentEl.querySelector('.streaming-summary');
            if (summary) {
                summary.textContent = `${tokenCount} tokens in ${duration}s`;
            }

            currentStreamingSession = null;
        }

        // Check filters
        function matchesFilters(data) {
            const json = JSON.stringify(data).toLowerCase();
            if (searchText && !json.includes(searchText.toLowerCase())) return false;
            if (typeFilter && data.type !== typeFilter) return false;
            if (componentFilter && data.component !== componentFilter) return false;
            return true;
        }

        // Append event to timeline
        function appendEvent(data) {
            const div = document.createElement('div');
            div.className = 'event';

            // Add special styling for StatusEvent levels and ErrorEvent
            if (data.type === 'StatusEvent' && data.data?.level) {
                const level = data.data.level;
                if (level === 'success') {
                    div.classList.add('status-success');
                    div.style.setProperty('--status-success-color', colorPalette['green'] || '#090');
                } else if (level === 'warning') {
                    div.classList.add('status-warning');
                    div.style.setProperty('--status-warning-color', colorPalette['yellow'] || '#f90');
                } else if (level === 'error') {
                    div.classList.add('status-error');
                    div.style.setProperty('--status-error-color', colorPalette['red'] || '#c00');
                } else if (level === 'key_info' || level === 'status') {
                    div.classList.add('status-key-info');
                }
            } else if (data.type === 'ErrorEvent') {
                div.classList.add('status-error');
                div.style.setProperty('--status-error-color', colorPalette['red'] || '#c00');
            }

            const msg = getMsg(data);
            const time = data.created_at ? new Date(data.created_at).toLocaleTimeString() : '';
            const json = JSON.stringify(data, null, 2);

            // Get component color from config (always use font color)
            const compColor = getComponentColor(data.component);
            let compStyle = compColor ? `style="color: ${compColor}"` : '';

            div.innerHTML = `
                <div class="event-row">
                    <span class="event-tag">${data.type || 'unknown'}</span>
                    ${data.component ? `<span class="event-component" data-color="${compColor || ''}" ${compStyle}>[${data.component}]</span>` : ''}
                    <span class="event-msg">${escapeHtml(msg)}</span>
                    <span class="event-time">${time}</span>
                </div>
                <div class="event-details">
                    <div class="details-actions">
                        <button class="copy-btn">Copy JSON</button>
                    </div>
                    <pre>${escapeHtml(json)}</pre>
                </div>
            `;

            const row = div.querySelector('.event-row');
            row.onclick = () => div.classList.toggle('expanded');
            row.onmouseenter = (e) => {
                tooltipTimeout = setTimeout(() => showTooltip(data, e), 300);
            };
            row.onmousemove = (e) => {
                if (tooltip.classList.contains('visible')) positionTooltip(e);
            };
            row.onmouseleave = () => {
                clearTimeout(tooltipTimeout);
                hideTooltip();
            };

            div.querySelector('.event-details').onclick = (e) => e.stopPropagation();
            div.querySelector('.copy-btn').onclick = (e) => {
                e.stopPropagation();
                navigator.clipboard.writeText(json);
                e.target.textContent = 'Copied!';
                setTimeout(() => e.target.textContent = 'Copy JSON', 1500);
            };

            timeline.appendChild(div);
        }

        // Get message preview based on event type
        function getMsg(event) {
            const d = event.data || {};
            const type = event.type;

            // Type-specific preview logic
            switch (type) {
                case 'StatusEvent':
                    return d.message || d.level || '';
                case 'PhaseStartEvent':
                    return d.description || `Phase: ${d.phase}`;
                case 'PhaseCompleteEvent':
                    return `${d.phase} ${d.success ? '✓' : '✗'}`;
                case 'TaskExtractedEvent':
                    return d.task ? d.task.slice(0, 80) : '';
                case 'CapabilitiesSelectedEvent':
                    return d.capability_names?.join(', ') || '';
                case 'PlanCreatedEvent':
                    return d.steps ? `${d.steps.length} steps planned` : '';
                case 'CapabilityStartEvent':
                    return d.capability_name || d.description || '';
                case 'CapabilityCompleteEvent':
                    return `${d.capability_name} ${d.success ? '✓' : '✗'}`;
                case 'LLMRequestEvent':
                    return d.prompt_preview || `[${d.model}]`;
                case 'LLMResponseEvent':
                    return d.response_preview || `${d.output_tokens} tokens`;
                case 'ToolUseEvent':
                    return d.tool_name || '';
                case 'ToolResultEvent':
                    return d.result_preview || d.tool_name || '';
                case 'CodeGeneratedEvent':
                    return d.code_preview || `[${d.language}]`;
                case 'CodeExecutedEvent':
                    return d.success ? (d.output_preview || '✓') : (d.error_message || '✗');
                case 'ApprovalRequiredEvent':
                    return d.action_description || d.approval_type || '';
                case 'ApprovalReceivedEvent':
                    return `${d.approved ? '✓' : '✗'} ${d.user_message || ''}`.trim();
                case 'ResultEvent':
                    return d.response ? d.response.slice(0, 80) : (d.success ? '✓' : '✗');
                case 'ErrorEvent':
                    return d.error_message || d.error_type || '';
                // System events (not TypedEvents - fields at top level)
                case 'connected':
                    return event.message || 'Connected';
                case 'execution_started':
                    return event.query ? `Query: ${event.query}` : 'Started';
                case 'execution_completed':
                    return `Completed (${event.event_count || 0} events)`;
                case 'execution_error':
                    return event.error || 'Error';
                case 'pong':
                    return 'Pong';
                default:
                    // Unknown types - check top-level fields first, then data
                    if (event.message) return event.message;
                    if (event.query) return `Query: ${event.query}`;
                    if (event.error) return event.error;
                    return Object.keys(d).length > 0 ? JSON.stringify(d).slice(0, 80) : '';
            }
        }

        // Update filter dropdowns
        function updateFilterOptions() {
            const types = [...new Set(events.map(e => e.type).filter(Boolean))].sort();
            const comps = [...new Set(events.map(e => e.component).filter(Boolean))].sort();

            const currentType = typeFilter;
            const currentComp = componentFilter;

            typeFilterEl.innerHTML = '<option value="">All</option>' +
                types.map(t => `<option value="${t}" ${t === currentType ? 'selected' : ''}>${t}</option>`).join('');
            componentFilterEl.innerHTML = '<option value="">All</option>' +
                comps.map(c => `<option value="${c}" ${c === currentComp ? 'selected' : ''}>${c}</option>`).join('');
        }

        // Refresh timeline
        function refreshTimeline() {
            timeline.innerHTML = '';
            events.filter(matchesFilters).forEach(appendEvent);
            updateFilteredCount();
            timeline.scrollTop = timeline.scrollHeight;
        }

        function updateFilteredCount() {
            filteredCount.textContent = events.filter(matchesFilters).length;
        }

        // Execute
        function executeQuery() {
            const q = queryInput.value.trim();
            if (!q || !ws || ws.readyState !== WebSocket.OPEN) return;
            // Immediate visual feedback
            statusDot.classList.remove('connected');
            statusDot.classList.add('connecting', 'breathing');
            statusText.textContent = 'Executing...';
            ws.send(JSON.stringify({ action: 'execute', query: q }));
        }

        // Clear
        function clearEvents() {
            events = [];
            timeline.innerHTML = '';
            eventCount.textContent = '0';
            filteredCount.textContent = '0';
            searchText = '';
            typeFilter = '';
            componentFilter = '';
            searchInput.value = '';
            typeFilterEl.innerHTML = '<option value="">All</option>';
            componentFilterEl.innerHTML = '<option value="">All</option>';
            // Reset streaming response area
            streamingResponse.classList.remove('active', 'complete');
            streamingContent.textContent = '';
            // Reset streaming session
            currentStreamingSession = null;
        }

        // Export YAML
        function exportYAML() {
            // Simple YAML-like format (proper YAML would need a library)
            const yaml = events.map((e, i) => {
                return `- # Event ${i + 1}\n` +
                    Object.entries(e).map(([k, v]) => {
                        const val = typeof v === 'object' ? JSON.stringify(v) : v;
                        return `  ${k}: ${val}`;
                    }).join('\n');
            }).join('\n\n');

            const blob = new Blob([yaml], { type: 'text/yaml' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `osprey-events-${new Date().toISOString().slice(0,19).replace(/:/g,'-')}.yaml`;
            a.click();
            URL.revokeObjectURL(url);
        }

        function escapeHtml(text) {
            const div = document.createElement('div');
            div.textContent = text;
            return div.innerHTML;
        }

        // Tooltip functions
        function buildTooltipContent(event) {
            const d = event.data || {};
            const time = event.created_at ? new Date(event.created_at).toLocaleTimeString() : '';

            let html = `<div class="tooltip-header">${escapeHtml(event.type || 'Event')}</div>`;

            let hasCommonFields = false;
            if (event.component) {
                html += `<div class="tooltip-row"><span class="tooltip-label">Component:</span><span class="tooltip-value">${escapeHtml(event.component)}</span></div>`;
                hasCommonFields = true;
            }
            if (time) {
                html += `<div class="tooltip-row"><span class="tooltip-label">Time:</span><span class="tooltip-value">${time}</span></div>`;
                hasCommonFields = true;
            }

            const fields = getTooltipFields(event.type, d, event);
            if (fields.length > 0) {
                // Only add separator if we had common fields (header already has border-bottom)
                if (hasCommonFields) {
                    html += '<div class="tooltip-separator"></div>';
                }
                for (const [label, value] of fields) {
                    const displayVal = typeof value === 'string' ? value.slice(0, 100) : String(value);
                    html += `<div class="tooltip-row"><span class="tooltip-label">${escapeHtml(label)}:</span><span class="tooltip-value">${escapeHtml(displayVal)}</span></div>`;
                }
            }

            return html;
        }

        function getTooltipFields(type, d, event) {
            switch (type) {
                case 'StatusEvent':
                    return [['message', d.message], ['level', d.level], ['phase', d.phase]].filter(f => f[1]);
                case 'LLMRequestEvent':
                    return [['model', d.model], ['prompt', d.prompt_preview]].filter(f => f[1]);
                case 'LLMResponseEvent':
                    return [['response', d.response_preview], ['tokens', `${d.input_tokens}→${d.output_tokens}`]].filter(f => f[1]);
                case 'CapabilityStartEvent':
                    return [['capability', d.capability_name], ['step', `${d.step_number}/${d.total_steps}`]].filter(f => f[1]);
                case 'CapabilityCompleteEvent':
                    return [['capability', d.capability_name], ['success', d.success], ['duration', d.duration_ms ? `${d.duration_ms}ms` : null]].filter(f => f[1] !== undefined && f[1] !== null);
                case 'PhaseStartEvent':
                    return [['phase', d.phase], ['description', d.description]].filter(f => f[1]);
                case 'PhaseCompleteEvent':
                    return [['phase', d.phase], ['success', d.success], ['duration', d.duration_ms ? `${d.duration_ms}ms` : null]].filter(f => f[1] !== undefined && f[1] !== null);
                case 'CapabilitiesSelectedEvent':
                    const caps = d.capability_names?.join(', ') || '';
                    return [['capabilities', caps.length > 60 ? caps.slice(0, 60) + '...' : caps]].filter(f => f[1]);
                case 'PlanCreatedEvent':
                    return [['steps', d.steps ? `${d.steps.length} steps` : null]].filter(f => f[1]);
                case 'TaskExtractedEvent':
                    return [['task', d.task]].filter(f => f[1]);
                case 'ErrorEvent':
                    return [['error', d.error_message], ['type', d.error_type]].filter(f => f[1]);
                case 'connected':
                    return [['message', event.message]].filter(f => f[1]);
                case 'execution_started':
                    return [['query', event.query]].filter(f => f[1]);
                case 'execution_completed':
                    return [['events', event.event_count]].filter(f => f[1] !== undefined);
                default:
                    return Object.entries(d).slice(0, 3);
            }
        }

        function showTooltip(event, e) {
            tooltip.innerHTML = buildTooltipContent(event);
            tooltip.classList.add('visible');
            positionTooltip(e);
        }

        function positionTooltip(e) {
            const rect = tooltip.getBoundingClientRect();
            let x = e.clientX + 10;
            let y = e.clientY + 10;

            if (x + rect.width > window.innerWidth) x = e.clientX - rect.width - 10;
            if (y + rect.height > window.innerHeight) y = e.clientY - rect.height - 10;

            tooltip.style.left = x + 'px';
            tooltip.style.top = y + 'px';
        }

        function hideTooltip() {
            tooltip.classList.remove('visible');
        }

        // Reset filters
        function resetFilters() {
            searchText = '';
            typeFilter = '';
            componentFilter = '';
            searchInput.value = '';
            typeFilterEl.value = '';
            componentFilterEl.value = '';
            refreshTimeline();
        }

        // Event listeners
        executeBtn.onclick = executeQuery;
        clearBtn.onclick = clearEvents;
        exportBtn.onclick = exportYAML;
        resetFiltersBtn.onclick = resetFilters;
        queryInput.onkeydown = (e) => { if (e.key === 'Enter') executeQuery(); };
        searchInput.oninput = () => { searchText = searchInput.value; refreshTimeline(); };
        typeFilterEl.onchange = () => { typeFilter = typeFilterEl.value; refreshTimeline(); };
        componentFilterEl.onchange = () => { componentFilter = componentFilterEl.value; refreshTimeline(); };

        // Initialize on page load (both in parallel)
        fetchColors();
        connect();
    </script>
</body>
</html>
