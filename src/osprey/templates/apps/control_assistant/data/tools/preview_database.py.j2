"""
Preview Database Presentation Script

Shows how the channel database will be presented to the LLM.
Auto-detects pipeline type (hierarchical vs in_context) and displays accordingly.
"""

import sys
import argparse
from pathlib import Path

# Add project root to path
sys.path.insert(0, str(Path(__file__).parent.parent.parent.parent))

from {{ package_name }}.services.channel_finder.utils.config import get_config, resolve_path
from {{ package_name }}.services.channel_finder.databases import TemplateChannelDatabase, HierarchicalChannelDatabase, MiddleLayerDatabase

from rich.console import Console
from rich.table import Table
from rich.panel import Panel
from rich.tree import Tree
from rich import box

try:
    from osprey.cli.styles import console as osprey_console, get_active_theme, Messages
    console = osprey_console
    theme = get_active_theme()
except ImportError:
    # Fallback if osprey styles not available
    console = Console()
    theme = None
    Messages = None


def detect_pipeline_config(config) -> tuple[str | None, dict | None]:
    """Detect which pipeline is configured.

    Returns:
        tuple: (pipeline_type, db_config) where pipeline_type is 'hierarchical', 'in_context', or 'middle_layer'
    """
    cf_config = config.get('channel_finder', {})
    pipelines = cf_config.get('pipelines', {})

    # Check for explicit pipeline_mode setting
    pipeline_mode = cf_config.get('pipeline_mode')

    # Get pipeline configurations
    hierarchical_config = pipelines.get('hierarchical', {})
    in_context_config = pipelines.get('in_context', {})
    middle_layer_config = pipelines.get('middle_layer', {})

    # If pipeline_mode is explicitly set, use that
    if pipeline_mode == 'in_context' and in_context_config.get('database', {}).get('path'):
        return 'in_context', in_context_config.get('database', {})
    elif pipeline_mode == 'hierarchical' and hierarchical_config.get('database', {}).get('path'):
        return 'hierarchical', hierarchical_config.get('database', {})
    elif pipeline_mode == 'middle_layer' and middle_layer_config.get('database', {}).get('path'):
        return 'middle_layer', middle_layer_config.get('database', {})

    # Otherwise, fall back to checking which database exists (prefer middle_layer > hierarchical > in_context)
    if middle_layer_config.get('database', {}).get('path'):
        return 'middle_layer', middle_layer_config.get('database', {})
    elif hierarchical_config.get('database', {}).get('path'):
        return 'hierarchical', hierarchical_config.get('database', {})
    elif in_context_config.get('database', {}).get('path'):
        return 'in_context', in_context_config.get('database', {})
    else:
        return None, None


def preview_middle_layer(db_path: str, depth: int = 3, max_items: int = 3,
                         sections: list = None, focus: str = None, show_full: bool = False) -> None:
    """Preview middle layer database with tree structure.

    Args:
        db_path: Path to database file
        depth: Maximum depth to display in tree (default: 3, -1 for unlimited)
        max_items: Maximum items per level (default: 3, -1 for unlimited)
        sections: List of sections to display (tree, stats, samples)
        focus: Path to focus on (e.g., "SR:BPM" to show only BPM family in SR system)
        show_full: Show complete tree (overrides depth/max_items)
    """
    if sections is None:
        sections = ['tree']

    # Header
    console.print()
    console.print(
        Panel.fit(
            "[bold primary]Middle Layer Database Preview[/bold primary]\n"
            "[dim]Shows the functional hierarchy (System ‚Üí Family ‚Üí Field ‚Üí Channels)[/dim]",
            border_style="primary",
            padding=(1, 2)
        )
    )

    # Configuration table
    config_table = Table(show_header=False, box=box.SIMPLE, padding=(0, 2))
    config_table.add_column("Property", style="label")
    config_table.add_column("Value", style="value")

    resolved_path = resolve_path(db_path)
    config_table.add_row("Database Path", db_path)
    config_table.add_row("Database Type", "middle_layer")
    config_table.add_row("Resolved Path", str(resolved_path))

    console.print()
    console.print(Panel(config_table, title="[bold]Configuration[/bold]", border_style="info"))

    # Load database
    with console.status("[bold info]Loading database...", spinner="dots"):
        database = MiddleLayerDatabase(str(resolved_path))
        all_channels = database.get_all_channels()

    total_channels = len(all_channels)
    console.print(f"\n[success]‚úì Successfully loaded [bold]{total_channels:,}[/bold] channels[/success]\n")

    # Calculate statistics
    if 'stats' in sections or 'tree' in sections:
        systems = set()
        families = set()
        fields = set()

        for channel in all_channels:
            # Middle layer channels have system/family/field as direct keys
            if 'system' in channel:
                systems.add(channel['system'])
            if 'family' in channel:
                families.add(channel['family'])
            if 'field' in channel:
                fields.add(channel['field'])

        # Build statistics table
        stats_table = Table(show_header=True, box=box.ROUNDED, padding=(0, 2))
        stats_table.add_column("Metric", style="label", no_wrap=True)
        stats_table.add_column("Count", justify="right", style="value")

        stats_table.add_row("Total Channels", f"{total_channels:,}")
        stats_table.add_row("Systems", f"{len(systems)}")
        stats_table.add_row("Families", f"{len(families)}")
        stats_table.add_row("Fields", f"{len(fields)}")

        console.print(Panel(stats_table, title="[bold]Database Statistics[/bold]",
                           border_style="accent", padding=(1, 2)))

    # Render tree if requested
    if 'tree' in sections:
        _render_middle_layer_tree(database, depth if not show_full else -1,
                                 max_items if not show_full else -1, focus)

    # Render samples if requested
    if 'samples' in sections:
        _render_samples_section(database)

    # Footer
    console.print()
    console.print(Panel.fit(
        f"[success]‚úì Preview complete! [bold]{total_channels:,}[/bold] total channels[/success]",
        border_style="success"
    ))
    console.print()


def _render_middle_layer_tree(database, depth, max_items, focus) -> None:
    """Render the middle layer hierarchy tree."""
    console.print()

    # Build tree from database structure
    tree_data = _build_middle_layer_tree(database)

    # Handle focus if specified
    if focus:
        focus_parts = focus.split(':')
        tree_root, tree_title = _navigate_middle_layer_focus(tree_data, focus_parts)
        if tree_root is None:
            console.print(f"[error]‚úó Focus path '{focus}' not found in database[/error]\n")
            return
    else:
        tree_root = tree_data
        tree_title = "[bold primary]Middle Layer Hierarchy[/bold primary]"

    tree = Tree(tree_title, guide_style="info")

    # Add systems to tree
    max_depth = depth if depth > 0 else 10
    max_items_val = None if max_items == -1 else max_items

    _add_middle_layer_nodes(tree, tree_root, 0, max_depth, max_items_val)

    console.print(Panel(tree, title="[bold]Hierarchy Tree[/bold]",
                       border_style="primary", padding=(1, 2)))

    if depth > 0 or max_items > 0:
        console.print()
        console.print(
            f"[info]üí° Tip:[/info] Use [bold]--full[/bold] flag to see complete hierarchy"
        )


def _build_middle_layer_tree(database) -> dict:
    """Build a hierarchical tree structure from middle layer database."""
    tree = {}

    # First, extract descriptions from the original JSON structure
    descriptions = {}
    for system_name, system_data in database.data.items():
        if not isinstance(system_data, dict):
            continue

        system_desc = system_data.get('_description', '')
        descriptions[system_name] = {'_description': system_desc, 'families': {}}

        for family_name, family_data in system_data.items():
            if not isinstance(family_data, dict) or family_name.startswith('_'):
                continue

            family_desc = family_data.get('_description', '')
            descriptions[system_name]['families'][family_name] = family_desc

    # Build channel count tree
    for channel in database.get_all_channels():
        # Middle layer channels have system/family/field as direct keys
        system = channel.get('system', 'Unknown')
        family = channel.get('family', 'Unknown')
        field = channel.get('field', 'Unknown')

        # Build nested structure
        if system not in tree:
            tree[system] = {
                '_channels': 0,
                '_families': {},
                '_description': descriptions.get(system, {}).get('_description', '')
            }

        tree[system]['_channels'] += 1

        if family not in tree[system]['_families']:
            tree[system]['_families'][family] = {
                '_channels': 0,
                '_fields': {},
                '_description': descriptions.get(system, {}).get('families', {}).get(family, '')
            }

        tree[system]['_families'][family]['_channels'] += 1

        if field not in tree[system]['_families'][family]['_fields']:
            tree[system]['_families'][family]['_fields'][field] = 0

        tree[system]['_families'][family]['_fields'][field] += 1

    return tree


def _navigate_middle_layer_focus(tree, focus_parts) -> tuple[dict | None, str | None]:
    """Navigate to focus in middle layer tree."""
    current = tree
    title_parts = []

    for i, part in enumerate(focus_parts):
        title_parts.append(part)
        if i == 0:  # System level
            if part not in current:
                return None, None
            current = {'_families': current[part].get('_families', {})}
        elif i == 1:  # Family level
            if part not in current.get('_families', {}):
                return None, None
            current = {'_fields': current['_families'][part].get('_fields', {})}
        else:
            return None, None

    title = f"[bold primary]{':'.join(title_parts)}[/bold primary]"
    return current, title


def _add_middle_layer_nodes(parent, data, level, max_depth, max_items) -> None:
    """Recursively add middle layer nodes to tree."""
    if level >= max_depth:
        return

    # Determine what to show based on current level
    if level == 0:  # System level
        items = {k: v for k, v in data.items() if not k.startswith('_')}
        item_type = "system"
    elif '_families' in data:  # Family level
        items = data['_families']
        item_type = "family"
    elif '_fields' in data:  # Field level
        items = data['_fields']
        item_type = "field"
    else:
        return

    # Add items
    count = 0
    for name, node_data in sorted(items.items()):
        if max_items and count >= max_items:
            remaining = len(items) - max_items
            parent.add(f"[dim]... {remaining} more {item_type}s[/dim]")
            break

        count += 1

        # Get channel count
        if isinstance(node_data, dict):
            ch_count = node_data.get('_channels', 0)
        else:
            ch_count = node_data

        # Determine style and add description if available
        if level == 0:  # System level
            style = "cyan bold"
            desc_text = node_data.get('_description', '') if isinstance(node_data, dict) else ''
            # Truncate long descriptions for better display
            if len(desc_text) > 80:
                desc_text = desc_text[:77] + "..."
            desc = f" [dim]-[/dim] {desc_text}" if desc_text else ""
        elif level == 1:  # Family level
            style = "yellow"
            desc_text = node_data.get('_description', '') if isinstance(node_data, dict) else ''
            if len(desc_text) > 80:
                desc_text = desc_text[:77] + "..."
            desc = f" [dim]-[/dim] {desc_text}" if desc_text else ""
        else:  # Field level
            style = "green"
            desc = ""

        # Add node
        label = f"[{style}]{name}[/{style}] [dim]({ch_count} channels)[/dim]{desc}"
        branch = parent.add(label)

        # Recurse to next level
        if isinstance(node_data, dict) and level + 1 < max_depth:
            _add_middle_layer_nodes(branch, node_data, level + 1, max_depth, max_items)


def preview_hierarchical(db_path: str, depth: int = 3, max_items: int = 3,
                        sections: list = None, focus: str = None) -> None:
    """Preview hierarchical database with tree structure.

    Args:
        db_path: Path to database file
        depth: Maximum depth to display in tree (default: 3, -1 for unlimited)
        max_items: Maximum items per level (default: 3, -1 for unlimited)
        sections: List of sections to display (tree, stats, breakdown, samples)
        focus: Path to focus on (e.g., "M:QB" to show only QB family)
    """
    if sections is None:
        sections = ['tree']

    # Header
    console.print()
    console.print(
        Panel.fit(
            "[bold primary]Hierarchical Database Preview[/bold primary]\n"
            "[dim]Shows the tree structure of the hierarchical channel database[/dim]",
            border_style="primary",
            padding=(1, 2)
        )
    )

    # Configuration table
    config_table = Table(show_header=False, box=box.SIMPLE, padding=(0, 2))
    config_table.add_column("Property", style="label")
    config_table.add_column("Value", style="value")

    resolved_path = resolve_path(db_path)
    config_table.add_row("Database Path", db_path)
    config_table.add_row("Resolved Path", str(resolved_path))

    # Load database
    with console.status("[bold info]Loading database...", spinner="dots"):
        database = HierarchicalChannelDatabase(str(resolved_path))
        stats = database.get_statistics()
        hierarchy_levels = database.hierarchy_levels

    config_table.add_row("Hierarchy Levels", " ‚Üí ".join(hierarchy_levels))

    # Add display settings to config
    depth_str = "unlimited" if depth == -1 else str(depth)
    max_items_str = "unlimited" if max_items == -1 else str(max_items)
    config_table.add_row("Display Depth", depth_str)
    config_table.add_row("Max Items/Level", max_items_str)
    if focus:
        config_table.add_row("Focus Path", focus)

    console.print()
    console.print(Panel(config_table, title="[bold]Configuration[/bold]", border_style="info"))

    total_channels = stats.get('total_channels', 0)
    console.print(f"\n[success]‚úì Successfully loaded [bold]{total_channels}[/bold] channels[/success]\n")

    # Render requested sections
    if 'tree' in sections:
        _render_tree_section(database, hierarchy_levels, depth, max_items, focus)

    if 'stats' in sections:
        _render_stats_section(database, hierarchy_levels)

    if 'breakdown' in sections:
        _render_breakdown_section(database, hierarchy_levels, focus)

    if 'samples' in sections:
        _render_samples_section(database)

    # Footer
    console.print()
    footer_msg = f"[success]‚úì Preview complete! [bold]{total_channels}[/bold] total channels"
    if focus:
        footer_msg += f" (focused on: {focus})"
    footer_msg += "[/success]"

    console.print(Panel.fit(footer_msg, border_style="success"))
    console.print()


def _render_tree_section(database, hierarchy_levels, depth, max_items, focus):
    """Render the hierarchy tree section."""
    console.print()

    # Get the tree structure
    db_tree = database.tree

    # Handle focus path
    if focus:
        focus_parts = focus.split(':')
        tree_root, start_level = _navigate_to_focus(db_tree, focus_parts, hierarchy_levels, database)
        if tree_root is None:
            console.print(f"[error]‚úó Focus path '{focus}' not found in database[/error]\n")
            return
        tree_title = f"[bold primary]{focus}[/bold primary]"
    else:
        tree_root = db_tree
        start_level = 0
        tree_title = "[bold primary]Channel Database Hierarchy[/bold primary]"

    tree = Tree(tree_title, guide_style="info")

    # Build tree with depth and max_items limits
    max_depth = depth if depth > 0 else len(hierarchy_levels)
    max_items_val = None if max_items == -1 else max_items

    # Add top-level nodes
    item_count = 0
    for node_name, node_data in tree_root.items():
        if node_name.startswith('_'):
            continue

        if max_items_val and item_count >= max_items_val:
            remaining = len([k for k in tree_root.keys() if not k.startswith('_')]) - max_items_val
            tree.add(f"[dim]... {remaining} more {hierarchy_levels[start_level]}s[/dim]")
            break

        item_count += 1

        # Count channels for this node
        if start_level == 0:
            node_channels = [ch for ch in database.channel_map.values()
                           if ch.get('path', {}).get(hierarchy_levels[0]) == node_name]
        else:
            node_channels = _count_channels_matching_focus(database, focus_parts + [node_name], hierarchy_levels)

        node_branch = tree.add(
            f"[cyan bold]{node_name}[/cyan bold] [dim]({len(node_channels)} channels)[/dim]"
        )

        # Recursively add children if within depth limit
        if start_level + 1 < max_depth and isinstance(node_data, dict):
            _add_hierarchy_level_new(node_branch, node_data, database, hierarchy_levels,
                                    start_level + 1, max_items_val, max_depth, start_level, [node_name])

    console.print(Panel(tree, title="[bold]Hierarchy Tree[/bold]", border_style="primary", padding=(1, 2)))

    if depth > 0 or max_items > 0:
        console.print()
        console.print(
            f"[info]üí° Tip:[/info] Use [bold]--depth -1 --max-items -1[/bold] to see complete hierarchy"
        )


def _render_stats_section(database, hierarchy_levels):
    """Render the level statistics section."""
    console.print()

    # Build statistics for each level
    level_stats = _calculate_level_statistics(database, hierarchy_levels)

    stats_table = Table(show_header=True, box=box.ROUNDED, padding=(0, 2))
    stats_table.add_column("Level", style="label", no_wrap=True)
    stats_table.add_column("Name", style="accent", no_wrap=True)
    stats_table.add_column("Unique Values", justify="right", style="value")

    for idx, (level_name, unique_count) in enumerate(level_stats, 1):
        stats_table.add_row(str(idx), level_name, f"{unique_count:,}")

    console.print(Panel(stats_table, title="[bold]Hierarchy Level Statistics[/bold]",
                       border_style="accent", padding=(1, 2)))


def _render_breakdown_section(database, hierarchy_levels, focus):
    """Render channel count breakdown by path."""
    console.print()

    # Calculate breakdown
    breakdown = _calculate_breakdown(database, hierarchy_levels, focus)

    breakdown_table = Table(show_header=True, box=box.ROUNDED, padding=(0, 2))
    breakdown_table.add_column("Path", style="label", no_wrap=False)
    breakdown_table.add_column("Channels", justify="right", style="value")

    for path, count in breakdown[:20]:  # Limit to top 20
        breakdown_table.add_row(path, f"{count:,}")

    if len(breakdown) > 20:
        breakdown_table.add_row("[dim]...[/dim]", f"[dim]{len(breakdown) - 20} more paths[/dim]")

    console.print(Panel(breakdown_table, title="[bold]Channel Count Breakdown[/bold]",
                       border_style="accent", padding=(1, 2)))


def _render_samples_section(database, num_samples=5):
    """Render sample channel names."""
    console.print()

    import random
    all_channels = database.get_all_channels()

    if len(all_channels) <= num_samples:
        samples = all_channels
    else:
        samples = random.sample(all_channels, num_samples)

    sample_text = "\n".join([f"  {ch['channel']}" for ch in samples])
    sample_text += f"\n\n[dim]({len(samples)} random samples from {len(all_channels):,} total channels)[/dim]"

    console.print(Panel(sample_text, title="[bold]Sample Channels[/bold]",
                       border_style="accent", padding=(1, 2)))


def _navigate_to_focus(tree, focus_parts, hierarchy_levels, database):
    """Navigate to a focus path in the tree.

    Returns:
        tuple: (subtree_dict, start_level_index) or (None, None) if not found
    """
    current = tree
    level_idx = 0

    for part in focus_parts:
        if not isinstance(current, dict) or part not in current:
            return None, None
        current = current[part]
        level_idx += 1

    return current, level_idx


def _count_channels_matching_focus(database, path_parts, hierarchy_levels):
    """Count channels matching a focus path."""
    matching = []
    for ch_name, ch_data in database.channel_map.items():
        ch_path = ch_data.get('path', {})
        matches = True
        for idx, part in enumerate(path_parts):
            if idx < len(hierarchy_levels):
                if ch_path.get(hierarchy_levels[idx]) != part:
                    matches = False
                    break
        if matches:
            matching.append(ch_data)
    return matching


def _calculate_level_statistics(database, hierarchy_levels):
    """Calculate unique value counts for each hierarchy level."""
    level_counts = []

    for level_name in hierarchy_levels:
        unique_values = set()
        for ch_data in database.channel_map.values():
            path = ch_data.get('path', {})
            if level_name in path:
                unique_values.add(path[level_name])
        level_counts.append((level_name, len(unique_values)))

    return level_counts


def _calculate_breakdown(database, hierarchy_levels, focus):
    """Calculate channel count breakdown by path."""
    path_counts = {}

    for ch_data in database.channel_map.values():
        path = ch_data.get('path', {})

        # Build hierarchical paths
        for depth in range(1, len(hierarchy_levels) + 1):
            parts = []
            for i in range(depth):
                if i < len(hierarchy_levels):
                    level_name = hierarchy_levels[i]
                    if level_name in path:
                        parts.append(path[level_name])

            if parts:
                path_str = ":".join(parts)
                path_counts[path_str] = path_counts.get(path_str, 0) + 1

    # Sort by count descending
    sorted_breakdown = sorted(path_counts.items(), key=lambda x: (-x[1], x[0]))
    return sorted_breakdown


def _add_hierarchy_level_new(parent_branch, data, database, hierarchy_levels, level_idx,
                             max_items, max_depth, start_level, parent_path=None):
    """Recursively add hierarchy levels to the tree (new version with depth limit)."""
    if level_idx >= len(hierarchy_levels) or level_idx >= max_depth:
        return

    current_level = hierarchy_levels[level_idx]
    children = _get_children_at_level(data, current_level, hierarchy_levels, level_idx)

    if not children:
        return

    # Add child branches
    branch_count = 0
    for child_name, child_data in children.items():
        if max_items and branch_count >= max_items:
            parent_branch.add(f"[dim]... {len(children) - max_items} more {current_level}s[/dim]")
            break

        branch_count += 1

        # Build path for this child
        child_path = (parent_path or []) + [child_name]

        # Count channels matching this path
        child_channel_count = _count_channels_at_path(database, hierarchy_levels, child_path, level_idx)

        # Determine styling based on level
        if level_idx == max_depth - 1 or level_idx == len(hierarchy_levels) - 1:
            # Leaf level
            child_branch = parent_branch.add(f"[green]{child_name}[/green] [dim]({child_channel_count} channels)[/dim]")
        else:
            child_branch = parent_branch.add(f"[yellow]{child_name}[/yellow] [dim]({child_channel_count} channels)[/dim]")

        # Recurse to next level if within depth limit
        if level_idx + 1 < max_depth:
            _add_hierarchy_level_new(child_branch, child_data, database, hierarchy_levels,
                                    level_idx + 1, max_items, max_depth, start_level, child_path)


def _get_children_at_level(data, current_level, hierarchy_levels, level_idx):
    """Get children at a specific hierarchy level (works with both new and legacy formats)."""
    if not isinstance(data, dict):
        return {}

    # Check for _expansion (new format)
    if '_expansion' in data:
        expansion = data['_expansion']
        exp_type = expansion.get('_type')

        if exp_type == 'range':
            pattern = expansion.get('_pattern', '{}')
            start, end = expansion.get('_range', [1, 1])
            # Return a dict mapping instance names to the parent data
            return {pattern.format(i): data for i in range(start, end + 1)}
        elif exp_type == 'list':
            instances = expansion.get('_instances', [])
            return {inst: data for inst in instances}

    # Check for legacy format containers
    if current_level == "device" and 'devices' in data:
        device_config = data['devices']
        device_type = device_config.get('_type')

        if device_type == 'range':
            pattern = device_config.get('_pattern', '{}')
            start, end = device_config.get('_range', [1, 1])
            return {pattern.format(i): data for i in range(start, end + 1)}
        elif device_type == 'list':
            instances = device_config.get('_instances', [])
            return {inst: data for inst in instances}

    if current_level == "field" and 'fields' in data:
        return {k: v for k, v in data['fields'].items() if not k.startswith('_') and isinstance(v, dict)}

    if current_level == "subfield" and 'subfields' in data:
        return {k: v for k, v in data['subfields'].items() if not k.startswith('_') and isinstance(v, dict)}

    # Default: direct children (new format)
    return {k: v for k, v in data.items() if not k.startswith('_') and isinstance(v, dict)}


def _count_channels_at_path(database, hierarchy_levels, path_values, current_level_idx):
    """Count channels matching a specific path through the hierarchy.

    Args:
        database: Database instance
        hierarchy_levels: List of hierarchy level names
        path_values: List of values for each level (e.g., ['M', 'QB', '0L'])
        current_level_idx: Index of the current level (0-based)

    Returns:
        Number of channels matching this path
    """
    count = 0
    for ch_data in database.channel_map.values():
        ch_path = ch_data.get('path', {})
        matches = True

        # Check if channel matches all levels in our path
        for idx, value in enumerate(path_values):
            if idx <= current_level_idx and idx < len(hierarchy_levels):
                level_name = hierarchy_levels[idx]
                if ch_path.get(level_name) != value:
                    matches = False
                    break

        if matches:
            count += 1

    return count


def _add_hierarchy_level(parent_branch, data, database, hierarchy_levels, level_idx,
                         max_branches, show_full):
    """Recursively add hierarchy levels to the tree."""
    if level_idx >= len(hierarchy_levels):
        return

    current_level = hierarchy_levels[level_idx]

    # Navigate the hierarchical structure based on current level
    if current_level == "system":
        # Systems are direct children (non-underscore keys)
        children = {k: v for k, v in data.items() if not k.startswith('_') and isinstance(v, dict)}
    elif current_level == "family":
        # Families are direct children (non-underscore keys)
        children = {k: v for k, v in data.items() if not k.startswith('_') and isinstance(v, dict)}
    elif current_level == "device":
        # Devices are in the "devices" container - need to expand based on type
        if 'devices' not in data:
            return
        device_config = data['devices']
        device_type = device_config.get('_type')

        if device_type == 'range':
            pattern = device_config.get('_pattern', '{}')
            start, end = device_config.get('_range', [1, 1])
            # For preview, just show the range info, not all devices
            if not show_full and (end - start + 1) > max_branches:
                # Show just a few examples
                for i in range(start, start + max_branches):
                    device_name = pattern.format(i)
                    child_channel_count = _count_channels_for_device(data, device_name)
                    child_branch = parent_branch.add(
                        f"[yellow]{device_name}[/yellow] [dim]({child_channel_count} channels)[/dim]"
                    )
                    _add_hierarchy_level(child_branch, data, database, hierarchy_levels, level_idx + 1, max_branches, show_full)
                parent_branch.add(f"[dim]... {end - start + 1 - max_branches} more devices[/dim]")
                return
            else:
                children = {}
                for i in range(start, end + 1):
                    device_name = pattern.format(i)
                    children[device_name] = data  # Same data for all devices
        elif device_type == 'list':
            instances = device_config.get('_instances', [])
            children = {inst: data for inst in instances}
        else:
            return
    elif current_level == "field":
        # Fields are in the "fields" container
        if 'fields' not in data:
            return
        children = {k: v for k, v in data['fields'].items() if not k.startswith('_') and isinstance(v, dict)}
    elif current_level == "subfield":
        # Subfields are in the "subfields" container
        if 'subfields' not in data:
            return
        children = {k: v for k, v in data['subfields'].items() if not k.startswith('_') and isinstance(v, dict)}
    else:
        return

    # Add child branches
    branch_count = 0
    for child_name, child_data in children.items():
        if max_branches and branch_count >= max_branches:
            parent_branch.add(f"[dim]... {len(children) - max_branches} more {current_level}s[/dim]")
            break

        branch_count += 1

        # Determine what to display based on level
        if current_level == "subfield":
            # Subfields are channels themselves - no count needed
            child_branch = parent_branch.add(f"[success]{child_name}[/success]")
        elif current_level == "field":
            # Fields are just structural - no count needed, subfields below show the channels
            child_branch = parent_branch.add(f"[accent]{child_name}[/accent]")
        elif current_level == "family":
            # For families, show number of devices
            num_devices = _count_devices_in_family(child_data)
            child_branch = parent_branch.add(
                f"[accent]{child_name}[/accent] [dim]({num_devices} devices)[/dim]"
            )
        else:
            # For system and device levels, show channel count
            if current_level == "device":
                child_channel_count = _count_channels_for_device(data, child_name)
            else:
                child_channel_count = _count_channels_in_branch(child_data)

            child_branch = parent_branch.add(
                f"[accent]{child_name}[/accent] [dim]({child_channel_count} channels)[/dim]"
            )

        # Recurse to next level (but not for subfields since they're the leaf)
        if current_level != "subfield":
            _add_hierarchy_level(child_branch, child_data, database, hierarchy_levels,
                                level_idx + 1, max_branches, show_full)


def _count_devices_in_family(family_data):
    """Count number of devices in a family."""
    if 'devices' not in family_data:
        return 0

    device_config = family_data['devices']
    device_type = device_config.get('_type')

    if device_type == 'range':
        start, end = device_config.get('_range', [1, 1])
        return end - start + 1
    elif device_type == 'list':
        return len(device_config.get('_instances', []))

    return 0


def _count_channels_for_device(family_data, device_name):
    """Count channels for a specific device in a family."""
    count = 0
    if 'fields' in family_data:
        for field_name, field_data in family_data['fields'].items():
            if not field_name.startswith('_'):
                if 'subfields' in field_data:
                    count += len([k for k in field_data['subfields'].keys() if not k.startswith('_')])
                else:
                    count += 1  # Field itself is a channel
    return count


def _count_channels_in_branch(branch_data):
    """Recursively count all channels in a branch (for family-level counting)."""
    if not isinstance(branch_data, dict):
        return 0

    count = 0

    # If this has devices, count channels for all devices
    if 'devices' in branch_data:
        device_config = branch_data['devices']
        device_type = device_config.get('_type')

        if device_type == 'range':
            start, end = device_config.get('_range', [1, 1])
            num_devices = end - start + 1
            channels_per_device = _count_channels_for_device(branch_data, None)
            count = num_devices * channels_per_device
        elif device_type == 'list':
            num_devices = len(device_config.get('_instances', []))
            channels_per_device = _count_channels_for_device(branch_data, None)
            count = num_devices * channels_per_device

    # If this has fields directly (no devices), count them
    elif 'fields' in branch_data:
        for field_name, field_data in branch_data['fields'].items():
            if not field_name.startswith('_'):
                if isinstance(field_data, dict) and 'subfields' in field_data:
                    count += len([k for k in field_data['subfields'].keys() if not k.startswith('_')])
                else:
                    count += 1

    return count


def preview_in_context(db_path: str, presentation_mode: str, show_full: bool = False):
    """Preview in-context database with formatted channel list."""

    # Header
    console.print()
    console.print(
        Panel.fit(
            "[bold primary]In-Context Database Preview[/bold primary]\n"
            "[dim]Shows how the channel database will be presented to the LLM[/dim]",
            border_style="primary",
            padding=(1, 2)
        )
    )

    # Configuration table
    config_table = Table(show_header=False, box=box.SIMPLE, padding=(0, 2))
    config_table.add_column("Property", style="label")
    config_table.add_column("Value", style="value")

    config_table.add_row("Database Path", db_path)
    config_table.add_row("Presentation Mode", f"[success]{presentation_mode}[/success]")

    # Load database
    resolved_path = resolve_path(db_path)
    config_table.add_row("Resolved Path", str(resolved_path))

    console.print()
    console.print(Panel(config_table, title="[bold]Configuration[/bold]", border_style="info"))

    # Load database with spinner
    with console.status("[bold info]Loading database...", spinner="dots"):
        database = TemplateChannelDatabase(str(resolved_path), presentation_mode=presentation_mode)
        all_channels = database.get_all_channels()
        stats = database.get_statistics()

    console.print(f"\n[success]‚úì Successfully loaded [bold]{len(all_channels)}[/bold] channels[/success]\n")

    # Statistics table
    stats_table = Table(show_header=True, box=box.ROUNDED, padding=(0, 2))
    stats_table.add_column("Metric", style="label", no_wrap=True)
    stats_table.add_column("Count", justify="right", style="value")

    stats_table.add_row("Total Channels", str(len(all_channels)))
    if stats:
        template_entries = stats.get('template_entries', 0)
        standalone_entries = stats.get('standalone_entries', 0)
        if template_entries > 0 or standalone_entries > 0:
            stats_table.add_row("Template Entries", str(template_entries))
            stats_table.add_row("Standalone Entries", str(standalone_entries))

    console.print(Panel(stats_table, title="[bold]Database Statistics[/bold]", border_style="accent"))

    # Generate LLM preview
    console.print()
    if show_full:
        title = f"[bold]LLM Presentation[/bold] [dim](all {len(all_channels)} channels)[/dim]"
    else:
        title = f"[bold]LLM Presentation[/bold] [dim](first 20 channels)[/dim]"

    # Show channels (all or first 20)
    if show_full:
        sample_channels = all_channels
    else:
        sample_channels = all_channels[:20]

    formatted = database.format_chunk_for_prompt(sample_channels, include_addresses=False)

    # Display the formatted output in a panel
    console.print(Panel(
        formatted,
        title=title,
        border_style="primary",
        padding=(1, 2)
    ))

    if not show_full and len(all_channels) > 20:
        console.print()
        console.print(
            f"[dim]... {len(all_channels) - 20} more channels not shown[/dim]\n"
            f"[info]üí° Tip:[/info] Use [bold]--full[/bold] flag to see all channels"
        )

    # Footer
    console.print()
    console.print(
        Panel.fit(
            f"[success]‚úì Preview complete! [bold]{len(all_channels)}[/bold] total channels in database[/success]",
            border_style="success"
        )
    )
    console.print()


def preview_database(depth: int = 3, max_items: int = 3, sections: str = 'tree',
                     focus: str = None, show_full: bool = False, db_path: str = None) -> None:
    """Preview database based on configured pipeline type.

    Args:
        depth: Maximum depth to display (default: 3, -1 for unlimited)
        max_items: Maximum items per level (default: 3, -1 for unlimited)
        sections: Comma-separated list of sections to display
        focus: Path to focus on (hierarchical/middle_layer only)
        show_full: Sets depth and max_items to -1 for complete view
        db_path: Direct path to database file (overrides config)
    """

    # If path is provided directly, use it and auto-detect type
    if db_path:
        resolved_path = resolve_path(db_path)

        # Try to detect database type from file structure
        import json
        try:
            with open(resolved_path, 'r') as f:
                data = json.load(f)

            # Check for database type markers
            if 'hierarchy' in data or 'tree' in data:
                pipeline_type = 'hierarchical'
                db_config = {}  # Empty config for direct path usage
            elif isinstance(data, dict) and any(
                key in data for key in ['SR', 'BR', 'BTS', 'VAC', 'Scraper']
            ):
                # Middle layer databases have system-level keys like SR, BR, BTS, etc.
                pipeline_type = 'middle_layer'
                db_config = {}  # Empty config for direct path usage
            else:
                # Assume in_context/template format
                pipeline_type = 'in_context'
                db_config = {}  # Empty config for direct path usage
        except Exception as e:
            console.print(f"[error]‚úó Error loading database from {db_path}: {e}[/error]")
            sys.exit(1)
    else:
        # Use config file
        config = get_config()
        pipeline_type, db_config = detect_pipeline_config(config)

        if not pipeline_type:
            console.print()
            console.print(Panel(
                "[bold error]Error:[/bold error] No database configured\n\n"
                "[warning]Check config.yml:[/warning] Configure either:\n"
                "  ‚Ä¢ channel_finder.pipelines.middle_layer.database.path\n"
                "  ‚Ä¢ channel_finder.pipelines.hierarchical.database.path\n"
                "  ‚Ä¢ channel_finder.pipelines.in_context.database.path\n\n"
                "Or use [bold]--path[/bold] to specify a database file directly",
                border_style="error",
                title="‚ùå Configuration Error"
            ))
            sys.exit(1)

        db_path = db_config.get('path')

    # Handle --full flag (backwards compatibility)
    if show_full:
        depth = -1
        max_items = -1

    # Parse sections
    section_list = [s.strip() for s in sections.split(',')]
    if 'all' in section_list:
        section_list = ['tree', 'stats', 'breakdown', 'samples']

    if pipeline_type == 'hierarchical':
        preview_hierarchical(db_path=db_path, depth=depth, max_items=max_items,
                           sections=section_list, focus=focus)
    elif pipeline_type == 'middle_layer':
        preview_middle_layer(db_path=db_path, depth=depth, max_items=max_items,
                            sections=section_list, focus=focus, show_full=show_full)
    else:  # in_context
        presentation_mode = db_config.get('presentation_mode', 'template')
        # For in_context, only show_full is used (no depth/sections yet)
        preview_in_context(db_path, presentation_mode, show_full)


if __name__ == '__main__':
    parser = argparse.ArgumentParser(
        description='Preview channel database with flexible display options',
        formatter_class=argparse.RawDescriptionHelpFormatter,
        epilog="""
Examples:
  # Quick overview (default: 3 levels, 3 items per level)
  python preview_database.py

  # Show more items per level
  python preview_database.py --max-items 10

  # Show 4 levels with statistics
  python preview_database.py --depth 4 --sections tree,stats

  # Preview a specific database file
  python preview_database.py --path data/channel_databases/examples/optional_levels.json

  # Complete view with all sections
  python preview_database.py --depth -1 --max-items -1 --sections all

  # Focus on specific system/branch
  python preview_database.py --focus M:QB --depth 4

  # Just statistics for an example database
  python preview_database.py --path examples/consecutive_instances.json --sections stats

  # Backwards compatible
  python preview_database.py --full --sections stats

Sections:
  tree       - Hierarchy tree visualization (default)
  stats      - Per-level statistics (unique value counts)
  breakdown  - Channel count breakdown by path
  samples    - Random sample channel names
  all        - All of the above
        """
    )

    parser.add_argument(
        '--depth',
        type=int,
        default=3,
        help='Tree depth to display (default: 3, use -1 for unlimited)'
    )

    parser.add_argument(
        '--max-items',
        type=int,
        default=3,
        help='Maximum items per level (default: 3, use -1 for unlimited)'
    )

    parser.add_argument(
        '--sections',
        type=str,
        default='tree',
        help='Comma-separated sections to display: tree,stats,breakdown,samples,all (default: tree)'
    )

    parser.add_argument(
        '--focus',
        type=str,
        default=None,
        help='Focus on specific path (e.g., "M:QB" for QB family in M system)'
    )

    parser.add_argument(
        '--path',
        type=str,
        default=None,
        help='Direct path to database file (overrides config, auto-detects type)'
    )

    parser.add_argument(
        '--full',
        action='store_true',
        help='Show complete hierarchy (shorthand for --depth -1 --max-items -1)'
    )

    args = parser.parse_args()
    preview_database(
        depth=args.depth,
        max_items=args.max_items,
        sections=args.sections,
        focus=args.focus,
        show_full=args.full,
        db_path=args.path
    )
