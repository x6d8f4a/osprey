"""{{ app_display_name }} Framework Prompt Customizations - Task Extraction.

This module demonstrates control-system-specific customization of task extraction prompts
to improve handling of multi-turn conversations about channels, temporal references, and
control system operations.

**Why Customize Task Extraction?**

Task extraction is particularly critical for control systems because:

1. **Channel Reference Resolution**: Users often refer to channels from previous messages
   ("that channel", "those magnets", "the same ones")

2. **Temporal Context**: Historical data queries require precise time resolution
   ("an hour ago", "yesterday", "since the last fill")

3. **System/Device Patterns**: Conversations build on device families and systems
   ("all quadrupoles", "sector 4", "the dipoles we just looked at")

4. **Multi-Turn Workflows**: Users naturally explore data incrementally
   (current → historical → comparison → analysis)

**Facility-Agnostic Design**

These examples use generic control system terminology (magnets, vacuum, beam, etc.)
that applies across facilities. When adapting for your facility, consider:

- Adding facility-specific device naming patterns
- Including domain-specific terminology (e.g., "fill", "injection", "top-off")
- Customizing temporal patterns based on your facility's operations
- Adding examples for your most common query patterns

**Customization Approaches**

This template uses the **Advanced** approach: domain-specific examples that replace
framework defaults entirely. This reduces latency while providing better coverage
for control system operations.

The control system examples cover all necessary patterns (temporal references,
context resolution, memory usage, etc.) while using control system terminology
throughout. If you need framework defaults too, you can enable them:
    super().__init__(include_default_examples=True)

For more information on customizing framework prompts, see:
https://als-apg.github.io/osprey/developer-guides/03_core-framework-systems/04_prompt-customization.html
"""

import textwrap

from osprey.prompts.defaults import (
    DefaultTaskExtractionPromptBuilder,
    ExtractedTask,
    TaskExtractionExample,
)
from osprey.state import MessageUtils, UserMemories


class ControlSystemTaskExtractionPromptBuilder(DefaultTaskExtractionPromptBuilder):
    """Control-system-specific task extraction prompt builder.

    Provides comprehensive task extraction examples tailored for control system
    operations. These examples replace framework defaults with domain-specific
    patterns for channels, devices, and system monitoring workflows.

    The control system examples cover all necessary task extraction patterns
    (temporal references, context resolution, memory usage, etc.) while using
    terminology specific to accelerator and control system operations.

    **Tutorial Note**: Review the examples and adjust for your facility's specific
    terminology, device naming patterns, and common workflows.
    """

    def __init__(self):
        """Initialize with ONLY control system examples.

        The control system examples are comprehensive enough to cover all
        necessary task extraction patterns while being domain-specific and
        relevant to control system operations. This reduces prompt latency
        compared to including framework defaults.
        """
        super().__init__(include_default_examples=False)  # Use only control system examples
        self._add_control_system_examples()

    def get_role(self) -> str:
        """Get the control-system-specific role definition."""
        return "You are a control system assistant task extraction specialist that analyzes conversations to extract actionable tasks related to control system operations."

    def get_instructions(self) -> str:
        """Get the control-system-specific task extraction instructions."""
        return textwrap.dedent("""
        Your job is to:
        1. Understand what the user is asking for in the context of control system operations
        2. Extract a clear, actionable task related to channels, devices, or system monitoring
        3. Determine if the task depends on chat history context
        4. Determine if the task depends on user memory

        ## Control System Guidelines:
        - Create self-contained task descriptions executable without conversation context
        - Resolve channel references from previous messages ("that channel", "those magnets")
        - Resolve temporal references precisely ("an hour ago" → specific timestamp)
        - Extract device families and system names from conversation context
        - Carry forward channel addresses found in previous responses
        - Set depends_on_chat_history=True if task references previous messages
        - Set depends_on_user_memory=True only when task needs specific information from user memory
        - Be specific about channels, time ranges, and operations in task descriptions

        ## Control System Terminology:
        - BPM = Beam Position Monitor (NOT beats per minute - this is accelerator/beam diagnostics)
        - SP = Setpoint (desired value to write to a device)
        - RB/RBV = Readback/Readback Value (actual measured value from a device)
        - Common devices: quadrupoles (focusing magnets), dipoles (bending magnets), RF cavities, vacuum gauges

        ## Common Patterns:
        - Channel reference: "What about that magnet?" → resolve "magnet" to specific channel from history
        - Temporal: "Show me the last hour" → calculate exact start/end times
        - Comparative: "Compare with yesterday" → extract both current and historical requirements
        - Device families: "All quadrupoles in sector 2" → be explicit about the device pattern

        ## Write Operations:
        - Extract the target (channel/device) and value clearly
        - "Set X to Y" → task should specify both X and Y
        - For contextual values, extract the value from conversation history

        ## Computational Requests:
        - State the computational goal, not the implementation steps
        - "Plot X over time" → goal is to create the plot (orchestrator handles data retrieval)
        - "Calculate average" → goal is the calculation (orchestrator handles data gathering)
        """).strip()

    def _add_control_system_examples(self):
        """Add control-system-specific examples.

        These examples demonstrate common patterns in control system conversations.
        They use generic terminology (beam, magnets, vacuum, etc.) that applies
        across different types of facilities.

        **Tutorial Note**: When adapting for your facility, replace these with
        examples using your actual:
        - Device naming conventions
        - Common query patterns
        - Facility-specific terminology
        - Typical multi-turn workflows
        """

        # ===================================================================
        # PATTERN 1: Channel Reference Resolution
        # ===================================================================
        # Users often refer back to channels from previous operations
        # Task extraction identifies the dependency on previously found channels
        # NOTE: Channel addresses are stored in execution context, NOT parsed from messages

        self.examples.append(TaskExtractionExample(
            messages=[
                MessageUtils.create_user_message("Find the beam current monitor channel"),
                MessageUtils.create_assistant_message(
                    "I found the beam current monitor channel and it's ready to use."
                ),
                MessageUtils.create_user_message("What's the current value?"),
            ],
            user_memory=UserMemories(entries=[]),
            expected_output=ExtractedTask(
                task="Read the current value of the beam current monitor channel that was just found",
                depends_on_chat_history=True,
                depends_on_user_memory=False
            )
        ))

        # ===================================================================
        # PATTERN 2: Temporal Reference Resolution for Historical Data
        # ===================================================================
        # Historical queries require precise time resolution
        # "an hour ago" must resolve to actual timestamp

        self.examples.append(TaskExtractionExample(
            messages=[
                MessageUtils.create_user_message("What is the current beam current?"),
                MessageUtils.create_assistant_message(
                    "The current beam current is 350.2 mA, measured at 14:23:15."
                ),
                MessageUtils.create_user_message("What was it an hour ago?"),
            ],
            user_memory=UserMemories(entries=[]),
            expected_output=ExtractedTask(
                task="Retrieve historical data for the beam current channel from approximately one hour ago (around 13:23:15)",
                depends_on_chat_history=True,
                depends_on_user_memory=False
            )
        ))

        # ===================================================================
        # PATTERN 3: Device Family Reference with Context Carry-Forward
        # ===================================================================
        # Users explore device families incrementally
        # Task must maintain device context across turns

        self.examples.append(TaskExtractionExample(
            messages=[
                MessageUtils.create_user_message("Show me all quadrupole magnet current setpoints"),
                MessageUtils.create_assistant_message(
                    "I found 12 quadrupole magnet current setpoint channels. "
                    "These control the current settings for the focusing quadrupole magnets."
                ),
                MessageUtils.create_user_message("What about the readbacks?"),
            ],
            user_memory=UserMemories(entries=[]),
            expected_output=ExtractedTask(
                task="Find all quadrupole magnet current readback channels (corresponding readbacks for the quadrupole setpoints just found)",
                depends_on_chat_history=True,
                depends_on_user_memory=False
            )
        ))

        # ===================================================================
        # PATTERN 4: Multi-Turn Workflow - Current → Historical → Comparison
        # ===================================================================
        # Common control system workflow: check current, look at history, compare
        # Task must extract time references; channel addresses come from execution context

        self.examples.append(TaskExtractionExample(
            messages=[
                MessageUtils.create_user_message("What's the vacuum pressure in sector 3?"),
                MessageUtils.create_assistant_message(
                    "The vacuum pressure in sector 3 is currently 2.3e-9 Torr, "
                    "which is within normal operating range."
                ),
                MessageUtils.create_user_message("Has it been stable over the last 24 hours?"),
            ],
            user_memory=UserMemories(entries=[]),
            expected_output=ExtractedTask(
                task="Retrieve and analyze historical data for the sector 3 vacuum pressure channel over the last 24 hours to assess stability",
                depends_on_chat_history=True,
                depends_on_user_memory=False
            )
        ))

        # ===================================================================
        # PATTERN 5: System-Level Query with Implicit Reference
        # ===================================================================
        # Users often refer to "it" or "there" meaning a system or location
        # Task must resolve implicit references to specific context

        self.examples.append(TaskExtractionExample(
            messages=[
                MessageUtils.create_user_message("Find all vacuum pressure channels in sector 2"),
                MessageUtils.create_assistant_message(
                    "I found 5 vacuum pressure channels in sector 2 and they're ready to monitor."
                ),
                MessageUtils.create_user_message("Are there any issues there?"),
            ],
            user_memory=UserMemories(entries=[]),
            expected_output=ExtractedTask(
                task="Read current values of the sector 2 vacuum pressure channels that were just found and check for any abnormal readings indicating vacuum issues",
                depends_on_chat_history=True,
                depends_on_user_memory=False
            )
        ))

        # ===================================================================
        # PATTERN 6: Comparative Analysis with Specific Time Reference
        # ===================================================================
        # Users want to compare current state with specific past state
        # Task must extract both the current requirement and historical reference

        self.examples.append(TaskExtractionExample(
            messages=[
                MessageUtils.create_user_message("Show me the dipole magnet currents"),
                MessageUtils.create_assistant_message(
                    "The dipole magnet currents are currently all around 125 A, "
                    "within 0.2% of the nominal 125 A setting."
                ),
                MessageUtils.create_user_message("Compare these with the values from yesterday at this time"),
            ],
            user_memory=UserMemories(entries=[]),
            expected_output=ExtractedTask(
                task="Retrieve historical data for the dipole magnet current channels from 24 hours ago and compare with current values to identify any drift",
                depends_on_chat_history=True,
                depends_on_user_memory=False
            )
        ))

        # ===================================================================
        # PATTERN 7: Fresh Request with No Context Needed
        # ===================================================================
        # Not all queries need history - some are standalone
        # This demonstrates when depends_on_chat_history should be False

        self.examples.append(TaskExtractionExample(
            messages=[
                MessageUtils.create_user_message("Find all magnet power supply status channels"),
            ],
            user_memory=UserMemories(entries=[]),
            expected_output=ExtractedTask(
                task="Find all magnet power supply status channels in the control system",
                depends_on_chat_history=False,
                depends_on_user_memory=False
            )
        ))

        # ===================================================================
        # PATTERN 8: Progressive Problem Refinement
        # ===================================================================
        # Users progressively narrow down issues through conversation
        # Task must incorporate all relevant context from the dialogue

        self.examples.append(TaskExtractionExample(
            messages=[
                MessageUtils.create_user_message("I'm seeing some instability in the beam"),
                MessageUtils.create_assistant_message(
                    "I can help investigate the beam instability. Which parameter are you "
                    "observing the instability in - position, current, or something else?"
                ),
                MessageUtils.create_user_message("The beam position is oscillating"),
                MessageUtils.create_assistant_message(
                    "I understand you're seeing beam position oscillations. Which location "
                    "are you monitoring - can you specify the sector or beam position monitor (BPM)?"
                ),
                MessageUtils.create_user_message(
                    "It's at the BPM in sector 7, started about 30 minutes ago"
                ),
            ],
            user_memory=UserMemories(entries=[]),
            expected_output=ExtractedTask(
                task="Find the Beam Position Monitor (BPM) channel for sector 7 and retrieve historical data from 30 minutes ago to present to analyze beam position oscillations",
                depends_on_chat_history=True,
                depends_on_user_memory=False
            )
        ))

        # ===================================================================
        # PATTERN 9: Memory-Based Channel Preferences
        # ===================================================================
        # Users save frequently-monitored channels
        # Task must incorporate stored channel information from memory

        self.examples.append(TaskExtractionExample(
            messages=[
                MessageUtils.create_user_message("Check my critical channels"),
            ],
            user_memory=UserMemories(entries=[
                "[2025-01-15] Critical channels to monitor: BEAM:CURRENT:RB, VACUUM:SECT3:PRESSURE:RB, RF:CAVITY:POWER:RB"
            ]),
            expected_output=ExtractedTask(
                task="Read current values of critical monitoring channels: BEAM:CURRENT:RB, VACUUM:SECT3:PRESSURE:RB, and RF:CAVITY:POWER:RB",
                depends_on_chat_history=False,
                depends_on_user_memory=True
            )
        ))

        # ===================================================================
        # PATTERN 10: Memory-Based Operational Baselines
        # ===================================================================
        # Users store baseline values for comparison
        # Task must extract baseline from memory and specify comparison

        self.examples.append(TaskExtractionExample(
            messages=[
                MessageUtils.create_user_message("Compare current beam current with my baseline"),
            ],
            user_memory=UserMemories(entries=[
                "[2025-01-10 09:00] Baseline beam current: 400 mA ± 2 mA (BEAM:CURRENT:RB)",
                "[2025-01-10 09:05] Baseline vacuum pressure: 1.5e-9 Torr (VACUUM:SECT3:PRESSURE:RB)"
            ]),
            expected_output=ExtractedTask(
                task="Read current value of BEAM:CURRENT:RB and compare with baseline of 400 mA ± 2 mA to check if current beam current is within acceptable range",
                depends_on_chat_history=False,
                depends_on_user_memory=True
            )
        ))

        # ===================================================================
        # PATTERN 11: Memory + History - Recurring Issue Detection
        # ===================================================================
        # Users track recurring problems and want to check if they're happening again
        # Task must combine memory context with current state assessment

        self.examples.append(TaskExtractionExample(
            messages=[
                MessageUtils.create_user_message("Is that cooling issue happening again?"),
            ],
            user_memory=UserMemories(entries=[
                "[2025-01-12 14:30] Cooling issue pattern: RF cavity temperature (RF:CAVITY:TEMP:RB) spikes above 45°C when RF power exceeds 250 kW",
                "[2025-01-12 14:35] Monitor both RF:CAVITY:TEMP:RB and RF:CAVITY:POWER:RB together when investigating"
            ]),
            expected_output=ExtractedTask(
                task="Read current values of RF:CAVITY:TEMP:RB and RF:CAVITY:POWER:RB to check if the cooling issue pattern is occurring (temperature above 45°C when power exceeds 250 kW)",
                depends_on_chat_history=False,
                depends_on_user_memory=True
            )
        ))

        # ===================================================================
        # PATTERN 12: Conversational Query (No Technical Action)
        # ===================================================================
        # Not all queries require channel operations
        # This helps distinguish conversation from actionable tasks

        self.examples.append(TaskExtractionExample(
            messages=[
                MessageUtils.create_user_message("Hi, what can you help me with?"),
                MessageUtils.create_assistant_message(
                    "I'm your control system assistant! I can help you find channels, "
                    "read current values, retrieve historical data, analyze trends, and more."
                ),
                MessageUtils.create_user_message("What's the difference between setpoint and readback channels?"),
            ],
            user_memory=UserMemories(entries=[]),
            expected_output=ExtractedTask(
                task="Explain the difference between setpoint (SP) and readback (RB) channels in control systems",
                depends_on_chat_history=False,
                depends_on_user_memory=False
            )
        ))

        # ===================================================================
        # PATTERN 13: Write Based on Previous Context
        # ===================================================================
        # Users reference values from previous conversation when writing
        # Task must extract the actual value from conversation context

        self.examples.append(TaskExtractionExample(
            messages=[
                MessageUtils.create_user_message("What's the optimal corrector current?"),
                MessageUtils.create_assistant_message(
                    "Based on the beam parameters, the optimal corrector current is 12.5 A."
                ),
                MessageUtils.create_user_message("Set it to that value"),
            ],
            user_memory=UserMemories(entries=[]),
            expected_output=ExtractedTask(
                task="Set the corrector magnet current to the calculated optimal value of 12.5 A",
                depends_on_chat_history=True,
                depends_on_user_memory=False
            )
        ))

        # ===================================================================
        # PATTERN 14: Visualization/Plotting Request
        # ===================================================================
        # Users request plots or visualizations
        # Task states the GOAL (create plot), not the steps (find → retrieve → plot)
        # Orchestrator determines the workflow

        self.examples.append(TaskExtractionExample(
            messages=[
                MessageUtils.create_user_message("Plot the beam current over the last 2 hours"),
            ],
            user_memory=UserMemories(entries=[]),
            expected_output=ExtractedTask(
                task="Create a time-series plot of beam current data for the last 2 hours",
                depends_on_chat_history=False,
                depends_on_user_memory=False
            )
        ))
