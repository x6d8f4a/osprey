# {{ app_display_name }}

**A minimal Alpha Berkeley Framework application template optimized for easy integration of your APIs and workflows.**

This template is designed to be **LLM-friendly**, **agent-friendly**, and **human-friendly**, with clear documentation and examples showing exactly where to put your code.

---

## üéØ Purpose

This minimal template provides the simplest starting point for integrating **your custom functionality** into the Alpha Berkeley Framework. It includes:

‚úì **Complete example files** with inline documentation
‚úì **Clear guidance** on where to put your API calls, data structures, and logic
‚úì **Best practices** built into the template structure

---

## üìÇ Project Structure

```
{{ package_name }}/
‚îú‚îÄ‚îÄ README.md                    # This file
‚îú‚îÄ‚îÄ config.yml                   # Configuration (API keys, models, etc.)
‚îú‚îÄ‚îÄ pyproject.toml              # Dependencies
‚îú‚îÄ‚îÄ requirements.txt            # Python packages
‚îÇ
‚îî‚îÄ‚îÄ {{ package_name }}/         # Your application code
    ‚îú‚îÄ‚îÄ __init__.py
    ‚îÇ
    ‚îú‚îÄ‚îÄ context_classes.py      # Define your data structures HERE
    ‚îÇ   ‚îî‚îÄ‚îÄ Complete examples showing how to structure API responses,
    ‚îÇ       analysis results, and any data your capabilities work with
    ‚îÇ
    ‚îú‚îÄ‚îÄ registry.py             # Register your components HERE
    ‚îÇ   ‚îî‚îÄ‚îÄ Simple configuration file that tells the framework
    ‚îÇ       what capabilities and context classes you've created
    ‚îÇ
    ‚îî‚îÄ‚îÄ capabilities/           # Implement your logic HERE
        ‚îú‚îÄ‚îÄ __init__.py         # Overview and patterns
        ‚îî‚îÄ‚îÄ example_capability.py.j2
            ‚îî‚îÄ‚îÄ Complete template showing exactly how to:
                - Call external APIs
                - Process data
                - Handle errors
                - Return results
```

---

## üöÄ Quick Start

### 1. **Define Your Data Structures**

Edit `{{ package_name }}/context_classes.py`:

```python
class MyAPIResponseContext(CapabilityContext):
    """Container for your API response data."""
    CONTEXT_TYPE: ClassVar[str] = "MY_API_RESPONSE"
    CONTEXT_CATEGORY: ClassVar[str] = "COMPUTATIONAL_DATA"

    # Define fields matching your API response
    data: List[Dict[str, Any]] = Field(description="Response data from API")
    status: str = Field(description="API response status")
    timestamp: datetime = Field(description="When data was retrieved")

    # Implement required methods (see examples in file)
    def get_access_details(self, key: str) -> Dict[str, Any]:
        # Tell LLM how to access this data
        ...

    def get_summary(self) -> Dict[str, Any]:
        # Provide human-readable summary
        ...
```

**üëâ The file has complete examples showing different patterns!**

---

### 2. **Implement Your Capability**

Copy the template and customize it:

```bash
cd {{ package_name }}/capabilities/
cp example_capability.py.j2 my_api_capability.py
```

Edit `my_api_capability.py`:

```python
@capability_node
class MyAPICapability(BaseCapability):
    name = "my_api"
    description = "Calls my external API and returns data"
    provides = ["MY_API_RESPONSE"]
    requires = []  # Add dependencies if needed

    @staticmethod
    async def execute(state: AgentState, **kwargs):
        # YOUR API CALL GOES HERE
        response = await your_api_client.fetch_data()

        # Convert to context object
        output = MyAPIResponseContext(
            data=response['data'],
            status=response['status'],
            timestamp=datetime.now()
        )

        # Store and return using helper method
        return self.store_output_context(output)
```

**üëâ The template has 200+ lines of documentation explaining every part!**

---

### 3. **Register Your Components**

Edit `{{ package_name }}/registry.py`:

```python
return extend_framework_registry(
    capabilities=[
        CapabilityRegistration(
            name="my_api",
            module_path="{{ package_name }}.capabilities.my_api_capability",
            class_name="MyAPICapability",
            description="Calls my external API",
            provides=["MY_API_RESPONSE"],
            requires=[]
        ),
    ],

    context_classes=[
        ContextClassRegistration(
            context_type="MY_API_RESPONSE",
            module_path="{{ package_name }}.context_classes",
            class_name="MyAPIResponseContext"
        ),
    ],
)
```

**üëâ The file explains all options including dependencies, data sources, and exclusions!**

---

### 4. **Configure Your Application**

Edit `config.yml` to set:
- API keys and endpoints
- LLM model selection
- Approval modes
- Service configurations

---

### 5. **Run Your Application**

```bash
# Start the chat interface
framework chat

# Or deploy services
framework deploy up
```

---

## üìö Complete Integration Guide

### Common Integration Patterns

#### Pattern A: External API Integration

**Use Case**: You have a REST API, database, or external service to integrate

**Files to Create**:
1. Context class for API response (in `context_classes.py`)
2. Capability that calls the API (in `capabilities/my_api.py`)
3. Registration entries (in `registry.py`)

**Example Flow**:
```
User Query ‚Üí LLM Plans ‚Üí Your Capability ‚Üí API Call ‚Üí Context Object ‚Üí LLM Uses Data
```

**See**: `capabilities/example_capability.py.j2` - Pattern A section

---

#### Pattern B: Data Analysis / Transformation

**Use Case**: You need to process or analyze data from other capabilities

**Files to Create**:
1. Context class for analysis results (in `context_classes.py`)
2. Capability that performs analysis (in `capabilities/analyzer.py`)
3. Registration with requires=[] dependencies (in `registry.py`)

**Example Flow**:
```
API Data ‚Üí Your Analyzer ‚Üí Analysis Results ‚Üí LLM Generates Report
```

**See**: `capabilities/example_capability.py.j2` - Pattern B section

---

#### Pattern C: Knowledge Retrieval

**Use Case**: You have a knowledge base, documents, or RAG system

**Files to Create**:
1. Context class for knowledge results (in `context_classes.py`)
2. Capability that queries knowledge base (in `capabilities/knowledge.py`)
3. Data source provider (in `data_sources/knowledge_provider.py`)
4. Registration entries (in `registry.py`)

**Example Flow**:
```
User Query ‚Üí Knowledge Retrieval ‚Üí Documents/Data ‚Üí LLM Answers with Context
```

**See**: Wind turbine example in working examples

---

#### Pattern D: Multi-Step Workflow

**Use Case**: Complex process requiring multiple steps

**Files to Create**:
1. Context classes for each data type (in `context_classes.py`)
2. Multiple capabilities, each with clear provides/requires (in `capabilities/`)
3. Registration entries linking them (in `registry.py`)

**Example Flow**:
```
Step 1: Fetch Data ‚Üí DATA_CONTEXT
Step 2: Process Data (requires DATA_CONTEXT) ‚Üí PROCESSED_CONTEXT
Step 3: Analyze (requires PROCESSED_CONTEXT) ‚Üí ANALYSIS_CONTEXT
Step 4: Generate Report (requires ANALYSIS_CONTEXT) ‚Üí Final Response
```

**Framework automatically sequences steps based on provides/requires!**

---

## üéì Learning Resources

### Included in This Template

1. **`capabilities/example_capability.py.j2`**
   - Complete capability template with 200+ lines of documentation
   - Shows exactly where to put API calls, error handling, etc.
   - Multiple patterns for different use cases

2. **`context_classes.py`**
   - Multiple examples showing different data structures
   - Complete documentation of required methods
   - Guidance on LLM-friendly data access patterns

3. **`registry.py`**
   - Step-by-step guide to registration
   - Examples of all registration types
   - Troubleshooting guide

4. **`capabilities/__init__.py`**
   - Overview of capability patterns
   - Common integration scenarios
   - Best practices and anti-patterns

### Working Examples

Generate complete working examples to learn from:

```bash
# Simple weather API example
framework init my-weather --template hello_world_weather

# Advanced wind turbine monitoring example
framework init my-turbine --template wind_turbine
```

**Study these examples to see:**
- Real API integrations
- Multi-capability workflows
- Knowledge base integration
- Custom prompt providers
- Production-ready patterns

### Framework Documentation

- **Getting Started**: https://als-apg.github.io/osprey/getting-started/
- **Building Capabilities**: https://als-apg.github.io/osprey/developer-guides/building-first-capability.html
- **Context Classes**: https://als-apg.github.io/osprey/developer-guides/context-classes.html
- **Registry System**: https://als-apg.github.io/osprey/developer-guides/registry-and-discovery.html
- **Full API Reference**: https://als-apg.github.io/osprey/api_reference/

---

## üîß Development Workflow

### Typical Development Cycle

```bash
# 1. Define context class
vim {{ package_name }}/context_classes.py

# 2. Implement capability
vim {{ package_name }}/capabilities/my_capability.py

# 3. Register components
vim {{ package_name }}/registry.py

# 4. Test
framework chat

# 5. Debug if needed
tail -f logs/framework.log

# 6. Iterate
```

### Testing Your Integration

```bash
# Interactive testing
framework chat

# Check registry loaded correctly
python -c "from osprey.registry import get_registry; r = get_registry(); print([c.name for c in r.capabilities])"

# Verify context classes registered
python -c "from osprey.registry import get_registry; r = get_registry(); print([ct for ct in r.context_types.__dict__ if not ct.startswith('_')])"
```

### Debugging Tips

**Problem**: "Context type X not found in registry"
**Solution**: Add `ContextClassRegistration` for that type in `registry.py`

**Problem**: "Capability X not found"
**Solution**: Add `CapabilityRegistration` for that capability in `registry.py`

**Problem**: "Module {{ package_name }}.capabilities.X not found"
**Solution**: Check file exists and class name matches exactly

**Problem**: LLM doesn't use your capability
**Solution**: Improve `description` and add `_create_orchestrator_guide()`

**Problem**: LLM generates wrong Python code
**Solution**: Improve `get_access_details()` in your context class

---

## üéØ Integration Checklist

Use this checklist when integrating your API or workflow:

### Planning Phase
- [ ] Identify what data your API/workflow provides
- [ ] Identify what data it needs as input
- [ ] Sketch the data flow (User ‚Üí Capability ‚Üí Context ‚Üí LLM)
- [ ] Decide if you need one or multiple capabilities

### Implementation Phase
- [ ] Define context classes for your data types
- [ ] Implement `get_access_details()` and `get_summary()`
- [ ] Copy and customize capability template
- [ ] Implement `execute()` with your API calls/logic
- [ ] Add error handling in `classify_error()`
- [ ] Register capabilities and context classes
- [ ] Update `config.yml` with any configuration

### Testing Phase
- [ ] Run `framework chat` and test basic functionality
- [ ] Verify LLM can trigger your capability
- [ ] Check data flows correctly through context
- [ ] Test error handling with invalid inputs
- [ ] Review logs for any warnings/errors

### Optimization Phase
- [ ] Add `_create_orchestrator_guide()` for better LLM guidance
- [ ] Add `_create_classifier_guide()` for task classification
- [ ] Optimize context class `get_access_details()` for code generation
- [ ] Add comprehensive error handling
- [ ] Document any special usage notes

---

## üåü Key Design Principles

### 1. **LLM-Friendly Design**
- Clear, descriptive names for everything
- Rich descriptions in capability attributes
- `get_access_details()` tells LLM exact Python syntax
- Examples in orchestrator guides

### 2. **Type Safety**
- All data uses Pydantic models
- Automatic validation and serialization
- Clear field types and descriptions
- Prevents runtime type errors

### 3. **Modularity**
- Each capability does ONE thing well
- Clear dependencies via provides/requires
- Easy to add, remove, or modify capabilities
- Framework handles orchestration

### 4. **Observability**
- Logging throughout execution
- Context summaries for debugging
- Error classification for recovery
- Streaming status updates

### 5. **Simplicity**
- Minimal boilerplate
- Sensible defaults
- Framework handles complexity
- You focus on your domain logic

---

## ü§ù Framework Integration

### What the Framework Provides

When you use this template, you automatically get:

‚úì **Task Classification**: LLM determines which capabilities to use
‚úì **Orchestration**: LLM plans multi-step execution
‚úì **Memory**: Short and long-term context management
‚úì **Python Execution**: LLM can write and run analysis code
‚úì **Time Parsing**: Natural language time expressions
‚úì **Error Recovery**: Automatic retry and replanning
‚úì **Streaming**: Real-time status updates
‚úì **State Management**: Persistent agent state

### What You Provide

You focus on **your domain-specific logic**:

‚úì Your API integrations
‚úì Your data structures
‚úì Your business logic
‚úì Your domain knowledge

The framework handles the rest!

---

## üìñ Next Steps

1. **Start with the examples**: Read through all the template files
   - `context_classes.py` - Understand data structures
   - `capabilities/example_capability.py.j2` - See complete implementation
   - `registry.py` - Learn how to register components

2. **Study working examples**: Generate and explore complete applications
   ```bash
   framework init example-weather --template hello_world_weather
   framework init example-turbine --template wind_turbine
   ```

3. **Implement your integration**: Follow the Quick Start above

4. **Test and iterate**: Use `framework chat` to test your capabilities

5. **Optimize**: Add guides and improve descriptions for better LLM behavior

6. **Deploy**: Use `framework deploy up` to run in production

---

## üÜò Getting Help

### Documentation
- Framework docs: https://als-apg.github.io/osprey/
- API reference: https://als-apg.github.io/osprey/api_reference/

### Debugging
```python
# Check registry
from osprey.registry import get_registry
registry = get_registry()
print([c.name for c in registry.capabilities])

# Check context types
print([ct for ct in registry.context_types.__dict__ if not ct.startswith('_')])

# Test capability import
from {{ package_name }}.capabilities.my_capability import MyCapability
print(MyCapability.name, MyCapability.provides, MyCapability.requires)
```

### Common Issues
- See inline documentation in each file
- Check troubleshooting section in `registry.py`
- Review logs in `logs/framework.log`
- Compare with working examples (wind/weather)

---

## üí° Tips for Success

1. **Start Small**: Integrate one capability first, then add more
2. **Copy the Template**: `example_capability.py.j2` has everything you need
3. **Use Good Descriptions**: Help the LLM understand your capabilities
4. **Test Incrementally**: Test after each capability addition
5. **Study Examples**: The wind/weather examples show real-world patterns
6. **Read Inline Docs**: Every template file has extensive documentation
7. **Use Type Hints**: Pydantic catches errors early
8. **Log Everything**: Makes debugging much easier

---

**You're ready to integrate your functionality into the Alpha Berkeley Framework!**

Start by opening `{{ package_name }}/context_classes.py` and `{{ package_name }}/capabilities/example_capability.py.j2` to see complete, documented examples of exactly what to do.
