"""{{ app_display_name }} Application Registry.

━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
WHAT IS THE REGISTRY?
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

The registry is the "table of contents" for your application. It tells the framework:
1. What capabilities are available (your custom + framework's built-in)
2. What context classes define your data structures
3. What data sources provide knowledge/information
4. How everything connects together

Think of it as the "config file" that makes all your components discoverable.

━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
TWO REGISTRY STYLES
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

This template uses the COMPACT style with extend_framework_registry().

COMPACT STYLE (This File):
✓ Automatically includes framework capabilities (routing, memory, Python, etc.)
✓ You only register YOUR custom components
✓ Reduces boilerplate by ~70%
✓ Perfect for most use cases
✓ Can exclude or override framework components if needed

EXPLICIT STYLE:
✓ Full control - you register EVERYTHING
✓ No automatic framework inclusion
✓ More verbose but more flexible
✓ Use: framework init --registry-style explicit

For 90% of applications, COMPACT style is better!

━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
FRAMEWORK'S BUILT-IN CAPABILITIES
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

When you use extend_framework_registry(), you automatically get these capabilities:

1. routing           - Routes tasks to appropriate capabilities
2. memory            - Short and long-term memory management
3. python            - Execute Python code for analysis
4. time_range_parser - Parse time expressions ("last week", etc.)
5. classifier        - Classify tasks to determine required capabilities
6. user_approval     - Request user approval for sensitive operations

You don't need to register these - they're included automatically!

To see the full list programmatically:
    >>> from osprey.registry import get_framework_defaults
    >>> framework = get_framework_defaults()
    >>> print([c.name for c in framework.capabilities])
"""

from osprey.registry import (
    extend_framework_registry,
    CapabilityRegistration,
    ContextClassRegistration,
    DataSourceRegistration,
    FrameworkPromptProviderRegistration,
    RegistryConfig,
    RegistryConfigProvider
)


# ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
# REGISTRY PROVIDER CLASS
# ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

class {{ app_class_name }}RegistryProvider(RegistryConfigProvider):
    """Registry provider for {{ app_display_name }} application.

    This class is responsible for configuring your application's registry.
    The framework automatically discovers this class and uses it to:
    - Load your custom capabilities
    - Register your context classes
    - Configure data sources
    - Set up the complete component ecosystem

    ────────────────────────────────────────────────────────────────────────────
    HOW IT WORKS:
    ────────────────────────────────────────────────────────────────────────────

    1. Framework calls get_registry_config() at startup
    2. This method returns a complete RegistryConfig
    3. extend_framework_registry() merges framework + your components
    4. Framework loads and initializes all registered components
    5. Your capabilities are now available to the LLM orchestrator!

    ────────────────────────────────────────────────────────────────────────────
    TYPICAL USAGE PATTERNS:
    ────────────────────────────────────────────────────────────────────────────

    Pattern A: Simple Addition
      - Add your capabilities
      - Add your context classes
      - Use all framework capabilities
      → Most common pattern (see below)

    Pattern B: Exclude Framework Components
      - Add your capabilities
      - Exclude specific framework capabilities you don't need
      - Example: exclude_capabilities=["python"] if you don't want code execution
      → Good for security-sensitive or restricted environments

    Pattern C: Override Framework Components
      - Replace framework capability with custom implementation
      - Keep same name but provide your class
      - Example: Custom memory implementation
      → Advanced pattern for specialized needs
    """

    def get_registry_config(self) -> RegistryConfig:
        """Get application registry configuration.

        This method is called by the framework to build the complete registry.
        It uses extend_framework_registry() to combine framework defaults
        with your application-specific components.

        Returns:
            RegistryConfig: Complete registry with all components
        """

        # ────────────────────────────────────────────────────────────────────
        # REGISTRY CONFIGURATION
        # ────────────────────────────────────────────────────────────────────

        return extend_framework_registry(

            # ┌────────────────────────────────────────────────────────────┐
            # │ 1. REGISTER YOUR CAPABILITIES                              │
            # └────────────────────────────────────────────────────────────┘
            #
            # Each capability needs:
            # - name: Unique identifier (lowercase_with_underscores)
            # - module_path: Where to find the capability class
            # - class_name: Name of the capability class
            # - description: What it does (shown to LLM)
            # - provides: List of context types it creates
            # - requires: List of context types it needs as input
            #
            # The framework uses this to:
            # - Import and initialize your capability
            # - Plan execution sequences (based on provides/requires)
            # - Guide the LLM on when to use this capability

            capabilities=[
                # ────────────────────────────────────────────────────────
                # EXAMPLE CAPABILITY REGISTRATION
                # ────────────────────────────────────────────────────────
                # Uncomment and modify for your capability:
                #
                # CapabilityRegistration(
                #     name="my_api_capability",
                #     module_path="{{ package_name }}.capabilities.my_api_capability",
                #     class_name="MyAPICapability",
                #     description="Retrieves data from my external API",
                #     provides=["MY_API_RESPONSE"],
                #     requires=[]
                # ),

                # ────────────────────────────────────────────────────────
                # CAPABILITY WITH DEPENDENCIES
                # ────────────────────────────────────────────────────────
                # Example capability that needs input from another:
                #
                # CapabilityRegistration(
                #     name="data_analyzer",
                #     module_path="{{ package_name }}.capabilities.analyzer",
                #     class_name="DataAnalyzerCapability",
                #     description="Analyzes data from API responses",
                #     provides=["ANALYSIS_RESULTS"],
                #     requires=["MY_API_RESPONSE"]  # Needs output from above
                # ),

                # ────────────────────────────────────────────────────────
                # ADD YOUR CAPABILITIES HERE
                # ────────────────────────────────────────────────────────
                # TODO: Register your capabilities

            ],

            # ┌────────────────────────────────────────────────────────────┐
            # │ 2. REGISTER YOUR CONTEXT CLASSES                           │
            # └────────────────────────────────────────────────────────────┘
            #
            # Each context class needs:
            # - context_type: Unique identifier (must match CONTEXT_TYPE in class)
            # - module_path: Where to find the context class
            # - class_name: Name of the context class
            #
            # The framework uses this to:
            # - Serialize/deserialize context objects
            # - Validate context types in capability provides/requires
            # - Generate access patterns for LLM code generation

            context_classes=[
                # ────────────────────────────────────────────────────────
                # EXAMPLE CONTEXT CLASS REGISTRATION
                # ────────────────────────────────────────────────────────
                # Uncomment and modify for your context:
                #
                # ContextClassRegistration(
                #     context_type="MY_API_RESPONSE",
                #     module_path="{{ package_name }}.context_classes",
                #     class_name="MyAPIResponseContext"
                # ),
                #
                # ContextClassRegistration(
                #     context_type="ANALYSIS_RESULTS",
                #     module_path="{{ package_name }}.context_classes",
                #     class_name="AnalysisResultsContext"
                # ),

                # ────────────────────────────────────────────────────────
                # ADD YOUR CONTEXT CLASSES HERE
                # ────────────────────────────────────────────────────────
                # TODO: Register your context classes

            ],

            # ┌────────────────────────────────────────────────────────────┐
            # │ 3. REGISTER DATA SOURCES (Optional)                        │
            # └────────────────────────────────────────────────────────────┘
            #
            # Data sources provide knowledge or information to capabilities.
            # Use for:
            # - Knowledge bases / RAG systems
            # - Document repositories
            # - Database connections
            # - Mock data providers (for testing)
            #
            # Each data source needs:
            # - name: Unique identifier
            # - module_path: Where to find the data source class
            # - class_name: Name of the data source class
            # - description: What information it provides

            data_sources=[
                # ────────────────────────────────────────────────────────
                # EXAMPLE DATA SOURCE REGISTRATION
                # ────────────────────────────────────────────────────────
                # Uncomment and modify for your data source:
                #
                # DataSourceRegistration(
                #     name="my_knowledge_base",
                #     module_path="{{ package_name }}.data_sources.knowledge",
                #     class_name="MyKnowledgeProvider",
                #     description="Provides domain-specific knowledge and documentation"
                # ),

                # ────────────────────────────────────────────────────────
                # ADD YOUR DATA SOURCES HERE
                # ────────────────────────────────────────────────────────
                # TODO: Register your data sources (if any)

            ],

            # ┌────────────────────────────────────────────────────────────┐
            # │ 4. CUSTOM PROMPT PROVIDERS (Optional, Advanced)            │
            # └────────────────────────────────────────────────────────────┘
            #
            # Prompt providers customize framework prompts for your domain.
            # Use for:
            # - Domain-specific terminology
            # - Custom response formatting
            # - Specialized instructions for LLM
            #
            # Most applications don't need this - only for advanced customization!

            framework_prompt_providers=[
                # ────────────────────────────────────────────────────────
                # EXAMPLE PROMPT PROVIDER REGISTRATION
                # ────────────────────────────────────────────────────────
                # Uncomment and modify if you need custom prompts:
                #
                # FrameworkPromptProviderRegistration(
                #     application_name="{{ package_name }}",
                #     module_path="{{ package_name }}.prompts",
                #     description="Custom prompts for {{ app_display_name }}",
                #     prompt_builders={
                #         "response_generation": "CustomResponsePromptBuilder"
                #     }
                # ),

                # ────────────────────────────────────────────────────────
                # ADD CUSTOM PROMPT PROVIDERS HERE
                # ────────────────────────────────────────────────────────
                # TODO: Register custom prompt providers (rarely needed)

            ],

            # ┌────────────────────────────────────────────────────────────┐
            # │ 5. EXCLUDE FRAMEWORK CAPABILITIES (Optional)               │
            # └────────────────────────────────────────────────────────────┘
            #
            # Remove specific framework capabilities you don't need.
            #
            # Common exclusions:
            # - "python": If you don't want code execution
            # - "memory": If you implement custom memory
            # - "user_approval": If running without user interaction
            #
            # Most applications should NOT exclude anything!

            # exclude_capabilities=[
            #     # Example: Don't include Python execution capability
            #     # "python",
            # ],

            # ┌────────────────────────────────────────────────────────────┐
            # │ 6. OVERRIDE FRAMEWORK CAPABILITIES (Optional, Advanced)    │
            # └────────────────────────────────────────────────────────────┘
            #
            # Replace framework capability with your custom implementation.
            # The name must match the framework capability you're replacing.
            #
            # Example use cases:
            # - Custom memory with special persistence
            # - Specialized routing logic
            # - Domain-specific Python execution sandbox
            #
            # This is ADVANCED - only use if you really need it!

            # override_capabilities=[
            #     # Example: Replace framework memory with custom version
            #     # CapabilityRegistration(
            #     #     name="memory",  # Same name as framework capability
            #     #     module_path="{{ package_name }}.capabilities.custom_memory",
            #     #     class_name="CustomMemoryCapability",
            #     #     description="Custom memory implementation with special features",
            #     #     provides=["MEMORY_CONTEXT"],
            #     #     requires=[]
            #     # ),
            # ],
        )


# ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
# QUICK REFERENCE
# ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
#
# TYPICAL REGISTRATION SEQUENCE:
#
# 1. Create capability in capabilities/my_capability.py
# 2. Create context class in context_classes.py
# 3. Register both in this file (registry.py)
# 4. Run: framework chat
#
# COMPLETE EXAMPLE:
#
# # In context_classes.py:
# class WeatherDataContext(CapabilityContext):
#     CONTEXT_TYPE: ClassVar[str] = "WEATHER_DATA"
#     temperature: float = Field(description="Temperature in Celsius")
#     conditions: str = Field(description="Weather conditions")
#     # ... implement get_access_details() and get_summary()
#
# # In capabilities/weather_api.py:
# @capability_node
# class WeatherAPICapability(BaseCapability):
#     name = "weather_api"
#     description = "Fetch current weather data"
#     provides = ["WEATHER_DATA"]
#     requires = []
#     # ... implement execute()
#
# # In registry.py (this file):
# capabilities=[
#     CapabilityRegistration(
#         name="weather_api",
#         module_path="{{ package_name }}.capabilities.weather_api",
#         class_name="WeatherAPICapability",
#         description="Fetch current weather data",
#         provides=["WEATHER_DATA"],
#         requires=[]
#     ),
# ],
# context_classes=[
#     ContextClassRegistration(
#         context_type="WEATHER_DATA",
#         module_path="{{ package_name }}.context_classes",
#         class_name="WeatherDataContext"
#     ),
# ],
#
# ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
# TROUBLESHOOTING
# ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
#
# ERROR: "Context type X not found in registry"
# → Add ContextClassRegistration for that context type
#
# ERROR: "Capability X not found"
# → Add CapabilityRegistration for that capability
#
# ERROR: "Module {{ package_name }}.capabilities.X not found"
# → Check that the file exists and class name matches
#
# ERROR: "Circular dependency detected"
# → Check provides/requires - you have a dependency loop
#
# To debug registry issues:
# >>> from osprey.registry import get_registry
# >>> registry = get_registry()
# >>> print([c.name for c in registry.capabilities])
# >>> print([ct for ct in registry.context_types.__dict__ if not ct.startswith('_')])
#
# ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
