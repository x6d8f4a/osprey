"""
Example Capability Template

This is a complete example showing how to implement a capability in the Osprey Framework.
Copy this file and modify it for your specific use case.

━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
WHAT IS A CAPABILITY?
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

A capability is a self-contained unit of functionality that:
1. Takes inputs (context) from the agent state
2. Performs some operation (API call, computation, data retrieval, etc.)
3. Returns outputs (context) back to the agent state

Think of it as a function that the LLM can call to accomplish specific tasks.

━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
INTEGRATION GUIDE FOR YOUR API/WORKFLOW
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

WHERE TO PUT YOUR CODE:
├── 1. Define data structures → context_classes.py
├── 2. Implement API calls → capabilities/your_capability.py (this file)
└── 3. Register components → registry.py

TYPICAL INTEGRATION PATTERNS:

Pattern A: External API Integration
  - Import your API client
  - Make API calls in execute()
  - Convert API responses to context objects
  - Examples: weather APIs, database queries, REST APIs

Pattern B: Computation/Analysis
  - Accept data from other capabilities via requires=[]
  - Perform calculations/transformations
  - Return results as new context
  - Examples: data analysis, ML inference, report generation

Pattern C: Data Retrieval
  - Query databases, files, or knowledge bases
  - Format results for LLM consumption
  - Provide structured data access
  - Examples: knowledge retrieval, document search, data archiving
"""

# ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
# STEP 1: Import required framework components
# ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
import textwrap
from typing import Any, Dict, Optional

from osprey.base.capability import BaseCapability
from osprey.base.decorators import capability_node
from osprey.base.errors import ErrorClassification, ErrorSeverity
from osprey.context.context_manager import ContextManager
from osprey.registry import get_registry
from osprey.state import AgentState, StateManager

from {{ package_name }}.context_classes import ExampleContext

# Optional: Import your API client, external libraries, etc.
# import your_api_client
# import pandas as pd
# import requests


# ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
# STEP 2: Define custom exceptions (optional but recommended)
# ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
# Custom exceptions help with error handling and classification

class ExampleCapabilityError(Exception):
    """Base exception for this capability."""
    pass

class MissingInputError(ExampleCapabilityError):
    """Raised when required input context is missing."""
    pass

class APICallError(ExampleCapabilityError):
    """Raised when external API call fails."""
    pass


# ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
# STEP 3: Implement your capability class
# ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

@capability_node  # Required decorator - registers this as a capability
class ExampleCapability(BaseCapability):
    """Example capability showing the complete implementation pattern.

    This capability demonstrates:
    - How to accept inputs from other capabilities
    - How to call external APIs or perform operations
    - How to return structured outputs
    - How to handle errors properly
    - How to guide the LLM orchestrator

    CUSTOMIZE THIS FOR YOUR USE CASE:
    - Replace "example" with your capability name
    - Update the description with what your capability actually does
    - Modify provides/requires based on your data flow
    """

    # ────────────────────────────────────────────────────────────────────────
    # REQUIRED ATTRIBUTES
    # ────────────────────────────────────────────────────────────────────────

    name = "example_capability"
    """Unique identifier for this capability. Used in registry and planning."""

    description = "Example capability that demonstrates the implementation pattern"
    """Human-readable description. Helps LLM understand when to use this capability."""

    provides = ["EXAMPLE_CONTEXT"]
    """What context types does this capability PROVIDE as output? Enables plan validation."""

    requires = [
        # List the context types this capability needs as input
        # Format: "CONTEXT_TYPE" or ("CONTEXT_TYPE", "single"|"multiple")
        # Example: "TIME_RANGE" or ("TIME_RANGE", "single")
    ]
    """What context types does this capability NEED as input?"""

    # ────────────────────────────────────────────────────────────────────────
    # REQUIRED METHOD: execute()
    # ────────────────────────────────────────────────────────────────────────

    async def execute(self) -> Dict[str, Any]:
        """
        Execute the capability's main logic.

        This is the core method where you implement your capability's functionality.
        The framework automatically provides access to execution state and step context
        through self._state and self._step.

        Implementation Steps:
        1. Extract required inputs using self.get_required_contexts()
        2. Get optional parameters using self.get_parameters()
        3. Perform your main work (API calls, computations, etc.)
        4. Create output context objects
        5. Store results using self.store_output_context()

        Returns:
            State updates dictionary for LangGraph to merge.

        Raises:
            MissingInputError: When required input context is not available.
            APICallError: When external API calls fail.
        """

        # ──────────────────────────────────────────────────────────────────
        # 3.1: Setup logging with automatic streaming support
        # ──────────────────────────────────────────────────────────────────
        logger = self.get_logger()
        logger.status("Starting example capability execution...")

        logger.debug(f"Executing example_capability for step: {self._step.get('context_key')}")

        # ──────────────────────────────────────────────────────────────────
        # 3.2: Extract required inputs (if any)
        # ──────────────────────────────────────────────────────────────────
        # If your capability has requires=["INPUT_DATA", "TIME_RANGE"], extract like this:

        # Elegant tuple unpacking (order matches requires field):
        # try:
        #     input_data, time_range = self.get_required_contexts()
        # except ValueError as e:
        #     raise MissingInputError(f"Missing required input: {e}")

        # Alternative dict access (if you prefer):
        # try:
        #     contexts = self.get_required_contexts()
        #     input_data = contexts["INPUT_DATA"]
        #     time_range = contexts["TIME_RANGE"]
        # except ValueError as e:
        #     raise MissingInputError(f"Missing required input: {e}")

        # For optional parameters from orchestrator:
        # params = self.get_parameters()
        # timeout = params.get('timeout', 30)

        # ──────────────────────────────────────────────────────────────────
        # 3.4: Perform your main work
        # ──────────────────────────────────────────────────────────────────
        # THIS IS WHERE YOU PUT YOUR API CALLS, COMPUTATIONS, ETC.

        try:
            # Example: Call your external API
            # response = await your_api_client.fetch_data(
            #     param1=required_input.some_field,
            #     param2="some_value"
            # )

            # Example: Perform computations
            # result = perform_analysis(required_input.data)

            # Example: Query a database
            # data = await database.query("SELECT * FROM table")

            # For demonstration, we'll create dummy data
            example_data = {
                "message": "Replace this with your actual implementation",
                "status": "success"
            }

            logger.info("Example capability executed successfully")

        except Exception as e:
            logger.error(f"Failed to execute capability: {e}")
            raise APICallError(f"Capability execution failed: {str(e)}")

        # ──────────────────────────────────────────────────────────────────
        # 3.5: Create output context object
        # ──────────────────────────────────────────────────────────────────
        # Convert your results into a context object (defined in context_classes.py)

        output_context = ExampleContext(
            # Map your API response / computation results to context fields
            # Example:
            # data_field=response['data'],
            # timestamp=datetime.now(),
            # status=response['status']
        )

        # ──────────────────────────────────────────────────────────────────
        # 3.6: Update streaming status
        # ──────────────────────────────────────────────────────────────────
        logger.success("Example capability completed")

        # ──────────────────────────────────────────────────────────────────
        # 3.7: Store output context and return
        # ──────────────────────────────────────────────────────────────────
        # Context objects are self-describing via their CONTEXT_TYPE attribute
        return self.store_output_context(output_context)

    # ────────────────────────────────────────────────────────────────────────
    # OPTIONAL METHOD: classify_error()
    # ────────────────────────────────────────────────────────────────────────

    @staticmethod
    def classify_error(exc: Exception, context: dict) -> ErrorClassification:
        """Classify errors to guide framework recovery behavior.

        The framework uses this to decide:
        - Should it retry the operation?
        - Should it replan the execution?
        - Is this a critical failure?

        Args:
            exc: The exception that was raised
            context: Additional context about the error

        Returns:
            ErrorClassification with severity and user message
        """

        if isinstance(exc, MissingInputError):
            # Missing dependencies -> need to replan
            return ErrorClassification(
                severity=ErrorSeverity.REPLANNING,
                user_message=f"Missing required input: {str(exc)}",
                metadata={"technical_details": str(exc)}
            )

        elif isinstance(exc, APICallError):
            # API failures -> can retry
            return ErrorClassification(
                severity=ErrorSeverity.RETRIABLE,
                user_message=f"API call failed: {str(exc)}",
                metadata={"technical_details": str(exc)}
            )

        else:
            # Unknown errors -> critical
            return ErrorClassification(
                severity=ErrorSeverity.CRITICAL,
                user_message=f"Unexpected error: {str(exc)}",
                metadata={"technical_details": str(exc)}
            )

    # ────────────────────────────────────────────────────────────────────────
    # OPTIONAL METHOD: _create_orchestrator_guide()
    # ────────────────────────────────────────────────────────────────────────

    def _create_orchestrator_guide(self) -> Optional['OrchestratorGuide']:
        """Create guidance for the LLM orchestrator.

        This tells the LLM:
        - When to use this capability
        - What inputs it needs
        - What outputs it provides
        - How to structure execution plans

        The better this guide, the better the LLM will use your capability!

        Returns:
            OrchestratorGuide or None to skip
        """

        from osprey.base.examples import (
            OrchestratorGuide,
            OrchestratorExample,
            PlannedStep
        )

        # Example 1: The capability step itself
        capability_example = OrchestratorExample(
            step=PlannedStep(
                context_key="my_example_data",  # Unique key for this execution
                capability="example_capability",  # Must match name attribute
                task_objective="Demonstrate how to use this capability",
                expected_output="EXAMPLE_CONTEXT",  # Must match provides
                success_criteria="Example data retrieved and formatted",
                inputs=[]  # Add input context keys if requires is not empty
            ),
            scenario_description="Example scenario showing capability usage",
            notes="Additional notes about when/how to use this capability"
        )

        # Example 2: How respond should consume this capability's output
        # This shows the complete workflow pattern - very important for smaller models!
        respond_example = OrchestratorExample(
            step=PlannedStep(
                context_key="user_response",
                capability="respond",
                task_objective="Inform the user about the results from example capability",
                expected_output="user_response",
                success_criteria="User receives information in a clear, friendly format",
                inputs=[{"EXAMPLE_CONTEXT": "my_example_data"}]  # References output from step 1
            ),
            scenario_description="After retrieving data, respond to the user with the information",
            notes="Takes EXAMPLE_CONTEXT from the previous step as input."
        )

        return OrchestratorGuide(
            instructions=textwrap.dedent("""
                **When to plan "example_capability" steps:**
                - Describe scenarios when the LLM should use this capability
                - Be specific about use cases
                - Explain the value this capability provides

                **Required Dependencies:**
                - List any required context types (from requires=[])
                - Explain where those dependencies come from

                **Step Structure:**
                - context_key: Unique identifier for output (e.g., "my_data")
                - task_objective: Specific goal for this execution
                - inputs: [] (or list of required context keys)

                **Output: EXAMPLE_CONTEXT**
                - Describe what data is returned
                - Pass this output to subsequent steps (like respond) that need the data
                - Note any important fields or structures
                """),
            examples=[capability_example, respond_example],  # 2-step example pattern
            priority=10  # Lower values appear first in orchestrator prompt
        )

    # ────────────────────────────────────────────────────────────────────────
    # OPTIONAL METHOD: _create_classifier_guide()
    # ────────────────────────────────────────────────────────────────────────

    def _create_classifier_guide(self) -> Optional['TaskClassifierGuide']:
        """Create guidance for task classification.

        This helps the LLM decide: "Does this user query need my capability?"

        Provide examples of queries that DO and DON'T need this capability.
        The more examples, the better the classification accuracy!

        Returns:
            TaskClassifierGuide or None to skip
        """

        from osprey.base.examples import (
            TaskClassifierGuide,
            ClassifierExample,
            ClassifierActions
        )

        return TaskClassifierGuide(
            instructions="Determine if the task requires example capability functionality.",
            examples=[
                ClassifierExample(
                    query="Example user query that NEEDS this capability",
                    result=True,
                    reason="Explain why this query needs your capability"
                ),
                ClassifierExample(
                    query="Example user query that DOESN'T need this capability",
                    result=False,
                    reason="Explain why this query doesn't need your capability"
                ),
                # Add 4-6 more examples for better accuracy
            ],
            actions_if_true=ClassifierActions()
        )


# ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
# NEXT STEPS
# ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
#
# 1. Copy this file and rename it for your capability
#    cp example_capability.py my_api_capability.py
#
# 2. Update the class name, name attribute, and description
#    class MyAPICapability(BaseCapability):
#        name = "my_api"
#        description = "Calls my external API"
#
# 3. Define your context classes in context_classes.py
#
# 4. Implement your logic in execute()
#
# 5. Register in registry.py:
#    CapabilityRegistration(
#        name="my_api",
#        module_path="{{ package_name }}.capabilities.my_api_capability",
#        class_name="MyAPICapability",
#        description="Calls my external API",
#        provides=["MY_API_RESPONSE"],
#        requires=[]
#    )
#
# 6. Test with: framework chat
#
# ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

