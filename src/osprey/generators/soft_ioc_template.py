"""Soft IOC Template Generator.

Generates pure Python EPICS soft IOCs using caproto from channel databases.
Supports all Osprey channel database types (flat, template, hierarchical, middle_layer).

Backend configuration is loaded at runtime from config.yml, allowing changes
without regenerating the IOC code.
"""

from __future__ import annotations

import re
from pathlib import Path


def generate_soft_ioc(
    config: dict,
    channels: list[dict],
    pairings: dict[str, str],
) -> str:
    """Generate soft IOC Python code.

    Args:
        config: Simulation configuration from config.yml (ioc settings, backend settings)
        channels: List of PV definitions from channel database
        pairings: Dict mapping setpoint PV names to readback PV names

    Returns:
        Complete Python source code for soft IOC
    """
    # Extract settings from config
    ioc_name = config["ioc"]["name"]
    port = config["ioc"]["port"]

    # Parse base + overlays config structure
    base = config.get("base", {"type": "mock_style"})
    overlays = config.get("overlays", [])

    # Extract update_rate from base backend (defaults)
    update_rate = base.get("update_rate", 10.0)

    ioc_class_name = _to_class_name(ioc_name)
    pv_definitions = _generate_pv_definitions(channels)
    pairings_literal = _generate_pairings_literal(pairings)

    scan_period = 1.0 / update_rate if update_rate > 0 else 0.1

    # Format backend info for docstring
    backend_names = []
    for backend in [base] + overlays:
        backend_type = backend.get("type")
        if backend_type:
            backend_names.append(backend_type)
        elif backend.get("class_name"):
            module = backend.get("module_path", "")
            cls = backend.get("class_name")
            backend_names.append(f"{module}::{cls}" if module else cls)
    backend_info = " + ".join(backend_names) if backend_names else "none"

    ioc_code = f'''#!/usr/bin/env python3
"""
{ioc_name} - EPICS Soft IOC

Generated by: osprey generate soft-ioc
Backend: {backend_info}
PV Count: {len(channels)}

Installation:
    pip install caproto numpy pyyaml

Usage:
    python {ioc_name}_ioc.py

    # With custom config file:
    python {ioc_name}_ioc.py --config /path/to/config.yml

    Server will run on EPICS CA port {port}
"""

import argparse
from pathlib import Path
from typing import Any

import yaml
from caproto import ChannelType
from caproto.server import PVGroup, ioc_arg_parser, pvproperty, run

from osprey.generators.ioc_backends import load_backends_from_config

# Default config path (relative to this file or cwd)
DEFAULT_CONFIG = Path(__file__).parent.parent / "config.yml"


# =============================================================================
# SP/RB Pairings (baked in from channel database)
# =============================================================================

PAIRINGS = {pairings_literal}


# =============================================================================
# IOC PV Group
# =============================================================================

class {ioc_class_name}(PVGroup):
    """
    {ioc_name} PV Group with simulation backend support.

    PV Count: {len(channels)}
    Backend: {backend_info}
    """

    def __init__(self, *args, backend=None, **kwargs):
        super().__init__(*args, **kwargs)
        self.backend = backend
        self._pv_map = {{}}  # name -> pvproperty for updates
        self._scan_period = {scan_period}  # Update rate from config
        self._initialized = False

    # --- PV Definitions ---
{pv_definitions}

    # --- Simulation Heartbeat ---
    sim_heartbeat = pvproperty(
        name='SIM:HEARTBEAT',
        value=0,
        read_only=True,
        doc='Simulation heartbeat counter'
    )

    @sim_heartbeat.startup
    async def sim_heartbeat(self, instance, async_lib):
        """Periodic simulation update loop."""
        # Build PV map on first access
        if not self._pv_map:
            for attr_name in dir(self):
                if attr_name.startswith('_'):
                    continue
                try:
                    attr = getattr(self, attr_name, None)
                    if hasattr(attr, 'pvname'):
                        self._pv_map[attr.pvname] = attr
                except Exception:
                    pass

        # Initialize backend with PV definitions
        if self.backend and not self._initialized:
            pv_defs = [
                {{'name': name, 'type': 'float'}}
                for name in self._pv_map.keys()
            ]
            initial_values = self.backend.initialize(pv_defs)

            # Apply initial values
            for pv_name, value in initial_values.items():
                if pv_name in self._pv_map:
                    try:
                        await self._pv_map[pv_name].write(value)
                    except Exception:
                        pass

            self._initialized = True

        # Simulation loop
        heartbeat = 0
        while True:
            await async_lib.library.sleep(self._scan_period)

            # Get updates from backend
            if self.backend:
                updates = self.backend.step(self._scan_period)
                for pv_name, value in updates.items():
                    if pv_name in self._pv_map:
                        try:
                            await self._pv_map[pv_name].write(value)
                        except Exception:
                            pass

            # Update heartbeat
            heartbeat = (heartbeat + 1) % 1000000
            await instance.write(heartbeat)

    async def group_write(self, instance, value):
        """Handle writes to PVs and call backend on_write."""
        # Prevent recursive writes from backend updates
        if getattr(self, '_in_backend_write', False):
            return value

        # Call backend on_write if available
        if self.backend and hasattr(self.backend, 'on_write'):
            pv_name = instance.pvspec.name
            updates = self.backend.on_write(pv_name, value)

            # Apply any updates from backend (excluding the current PV)
            if updates:
                self._in_backend_write = True
                try:
                    for update_pv, update_val in updates.items():
                        if update_pv == pv_name:
                            # Return transformed value for this PV
                            value = update_val
                        elif update_pv in self._pv_map:
                            try:
                                await self._pv_map[update_pv].write(update_val)
                            except Exception:
                                pass
                finally:
                    self._in_backend_write = False

        return value


# =============================================================================
# Main Entry Point
# =============================================================================

def print_startup_info(pv_count: int, port: int, backend_info: str):
    """Display server startup information."""
    print("=" * 70)
    print(f"{ioc_name} - EPICS Soft IOC")
    print("=" * 70)
    print(f"\\nEPICS CA Port: {{port}}")
    print(f"PV Count: {{pv_count}}")
    print(f"Backend: {{backend_info}}")
    print(f"\\nTo test:")
    print(f"  caget SIM:HEARTBEAT")
    print("\\nPress Ctrl+C to stop")
    print("=" * 70)


if __name__ == '__main__':
    # Parse arguments
    parser = argparse.ArgumentParser(description=__doc__)
    parser.add_argument(
        '--config', '-c',
        type=Path,
        default=DEFAULT_CONFIG,
        help='Path to config.yml (default: ../config.yml relative to this file)',
    )
    args, remaining = parser.parse_known_args()

    # Load config at runtime
    config_path = args.config
    if not config_path.exists():
        # Try current directory
        config_path = Path.cwd() / "config.yml"

    if config_path.exists():
        config = yaml.safe_load(config_path.read_text())
        sim_config = config.get("simulation", {{}})
    else:
        print(f"Warning: Config file not found at {{args.config}}, using defaults")
        sim_config = {{}}

    # Load backend from config (pass config dir for resolving relative file_path)
    backend = load_backends_from_config(sim_config, PAIRINGS, config_dir=config_path.parent)

    # Get backend info for display
    base = sim_config.get("base", {{"type": "mock_style"}})
    overlays = sim_config.get("overlays", [])
    backend_names = []
    for b in [base] + overlays:
        if b.get("type"):
            backend_names.append(b["type"])
        elif b.get("class_name"):
            backend_names.append(b["class_name"])
    backend_display = " + ".join(backend_names) if backend_names else "mock_style"

    # Parse caproto arguments
    ioc_options, run_options = ioc_arg_parser(
        default_prefix='',
        desc=__doc__
    )

    # Create IOC
    ioc = {ioc_class_name}(backend=backend, **ioc_options)

    # Print startup info
    print_startup_info({len(channels)}, {port}, backend_display)

    # Run server
    run(ioc.pvdb, **run_options)
'''
    return ioc_code


def _to_class_name(name: str) -> str:
    """Convert IOC name to class name (PascalCase).

    Args:
        name: IOC name (e.g., 'accelerator_sim')

    Returns:
        Class name (e.g., 'AcceleratorSim')
    """
    # Split on underscores and capitalize each part
    parts = name.replace("-", "_").split("_")
    return "".join(word.capitalize() for word in parts)


def sanitize_pv_name(pv_name: str) -> str:
    """Convert EPICS PV name to valid Python identifier.

    Args:
        pv_name: Original PV name (e.g., 'MAG:QUAD[Q01]:CURRENT:SP')

    Returns:
        Valid Python identifier (e.g., 'MAG_QUAD_Q01_CURRENT_SP')
    """
    # Replace invalid characters with underscore
    sanitized = re.sub(r"[:\[\]\-\.]", "_", pv_name)

    # Collapse multiple underscores
    sanitized = re.sub(r"_+", "_", sanitized)

    # Strip leading/trailing underscores
    sanitized = sanitized.strip("_")

    # Prefix with 'pv_' if starts with digit
    if sanitized and sanitized[0].isdigit():
        sanitized = "pv_" + sanitized

    # Ensure non-empty
    if not sanitized:
        sanitized = "pv_unnamed"

    return sanitized


def _generate_pv_definitions(channels: list[dict]) -> str:
    """Generate PV property definitions for all channels.

    Args:
        channels: List of PV definitions

    Returns:
        Python code string for PV definitions
    """
    lines = []
    seen_names = set()

    for pv in channels:
        pv_name = pv["name"]
        python_name = pv.get("python_name", sanitize_pv_name(pv_name))

        # Handle name collisions
        original_name = python_name
        counter = 1
        while python_name in seen_names:
            python_name = f"{original_name}_{counter}"
            counter += 1
        seen_names.add(python_name)

        pv_type = pv.get("type", "float")
        read_only = pv.get("read_only", False)
        description = pv.get("description", "")[:80]  # Truncate long descriptions
        # Escape quotes in description
        description = description.replace("'", "\\'")

        if pv_type == "float":
            lines.append(_generate_float_pv(python_name, pv_name, pv, description, read_only))
        elif pv_type == "int":
            lines.append(_generate_int_pv(python_name, pv_name, pv, description, read_only))
        elif pv_type == "enum":
            lines.append(_generate_enum_pv(python_name, pv_name, pv, description, read_only))
        elif pv_type == "string":
            lines.append(_generate_string_pv(python_name, pv_name, description, read_only))
        elif pv_type in ("float_array", "int_array"):
            lines.append(_generate_array_pv(python_name, pv_name, pv, description, read_only))
        else:
            # Default to float
            lines.append(_generate_float_pv(python_name, pv_name, pv, description, read_only))

    return "\n".join(lines)


def _generate_float_pv(
    python_name: str,
    epics_name: str,
    pv: dict,
    description: str,
    read_only: bool,
) -> str:
    """Generate a float PV property."""
    units = pv.get("units", "")
    precision = pv.get("precision", 4)
    high_alarm = pv.get("high_alarm", 100.0)
    low_alarm = pv.get("low_alarm", 0.0)

    return f"""    {python_name} = pvproperty(
        name='{epics_name}',
        value=0.0,
        precision={precision},
        units='{units}',
        upper_alarm_limit={high_alarm},
        lower_alarm_limit={low_alarm},
        read_only={read_only},
        doc='{description}'
    )
"""


def _generate_int_pv(
    python_name: str,
    epics_name: str,
    pv: dict,
    description: str,
    read_only: bool,
) -> str:
    """Generate an integer PV property."""
    units = pv.get("units", "")

    return f"""    {python_name} = pvproperty(
        name='{epics_name}',
        value=0,
        units='{units}',
        read_only={read_only},
        doc='{description}'
    )
"""


def _generate_enum_pv(
    python_name: str,
    epics_name: str,
    pv: dict,
    description: str,
    read_only: bool,
) -> str:
    """Generate an enum PV property."""
    enum_strings = pv.get("enum_strings", ["Off", "On"])

    return f"""    {python_name} = pvproperty(
        name='{epics_name}',
        value=0,
        dtype=ChannelType.ENUM,
        enum_strings={enum_strings},
        read_only={read_only},
        doc='{description}'
    )
"""


def _generate_string_pv(
    python_name: str,
    epics_name: str,
    description: str,
    read_only: bool,
) -> str:
    """Generate a string PV property."""
    return f"""    {python_name} = pvproperty(
        name='{epics_name}',
        value='',
        max_length=256,
        read_only={read_only},
        doc='{description}'
    )
"""


def _generate_array_pv(
    python_name: str,
    epics_name: str,
    pv: dict,
    description: str,
    read_only: bool,
) -> str:
    """Generate an array PV property."""
    count = pv.get("count", 128)

    return f"""    {python_name} = pvproperty(
        name='{epics_name}',
        value=[0.0] * {count},
        read_only={read_only},
        doc='{description}'
    )
"""


def _generate_pairings_literal(pairings: dict[str, str]) -> str:
    """Generate Python dict literal for pairings.

    Args:
        pairings: Dict mapping setpoint to readback PV names

    Returns:
        Python dict literal string
    """
    if not pairings:
        return "{}"

    lines = ["{"]
    for sp, rb in pairings.items():
        lines.append(f"    '{sp}': '{rb}',")
    lines.append("}")
    return "\n".join(lines)


def write_soft_ioc_file(
    output_path: Path,
    config: dict,
    channels: list[dict],
    pairings: dict[str, str],
) -> Path:
    """Generate and write soft IOC file.

    Args:
        output_path: Where to write the IOC file
        config: Simulation configuration
        channels: List of PV definitions
        pairings: SP->RB pairings

    Returns:
        Path to written file
    """
    code = generate_soft_ioc(config, channels, pairings)

    output_path.parent.mkdir(parents=True, exist_ok=True)
    output_path.write_text(code, encoding="utf-8")
    output_path.chmod(0o755)  # Make executable

    return output_path
