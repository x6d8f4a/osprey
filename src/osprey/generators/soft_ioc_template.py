"""Soft IOC Template Generator.

Generates pure Python EPICS soft IOCs using caproto from channel databases.
Supports all Osprey channel database types (flat, template, hierarchical, middle_layer).
"""

from __future__ import annotations

import re
from pathlib import Path


def generate_soft_ioc(
    config: dict,
    channels: list[dict],
    pairings: dict[str, str],
) -> str:
    """Generate soft IOC Python code.

    Args:
        config: Simulation configuration from config.yml (ioc settings, backend settings)
        channels: List of PV definitions from channel database
        pairings: Dict mapping setpoint PV names to readback PV names

    Returns:
        Complete Python source code for soft IOC
    """
    # Extract settings from config
    ioc_name = config["ioc"]["name"]
    port = config["ioc"]["port"]
    backend_type = config["backend"]["type"]
    noise_level = config["backend"]["noise_level"]
    update_rate = config["backend"]["update_rate"]

    ioc_class_name = _to_class_name(ioc_name)
    pv_definitions = _generate_pv_definitions(channels)
    backend_code = _generate_backend_code(backend_type, pairings, noise_level, update_rate)
    pairings_literal = _generate_pairings_literal(pairings)

    scan_period = 1.0 / update_rate if update_rate > 0 else 0.1

    ioc_code = f'''#!/usr/bin/env python3
"""
{ioc_name} - EPICS Soft IOC

Generated by: osprey generate soft-ioc
Backend: {backend_type}
PV Count: {len(channels)}

Installation:
    pip install caproto numpy

Usage:
    python {ioc_name}_ioc.py

    Server will run on EPICS CA port {port}
"""

import asyncio
import random
import time
from typing import Any

import numpy as np
from caproto import ChannelType
from caproto.server import PVGroup, ioc_arg_parser, pvproperty, run


# =============================================================================
# Simulation Backend
# =============================================================================

{backend_code}


# =============================================================================
# IOC PV Group
# =============================================================================

class {ioc_class_name}(PVGroup):
    """
    {ioc_name} PV Group with simulation backend support.

    PV Count: {len(channels)}
    Backend: {backend_type}
    """

    def __init__(self, *args, backend=None, **kwargs):
        super().__init__(*args, **kwargs)
        self.backend = backend
        self._pv_map = {{}}  # name -> pvproperty for updates
        self._scan_period = {scan_period}  # Update rate from config
        self._initialized = False

    # --- PV Definitions ---
{pv_definitions}

    # --- Simulation Heartbeat ---
    sim_heartbeat = pvproperty(
        name='SIM:HEARTBEAT',
        value=0,
        read_only=True,
        doc='Simulation heartbeat counter'
    )

    @sim_heartbeat.startup
    async def sim_heartbeat(self, instance, async_lib):
        """Periodic simulation update loop."""
        # Build PV map on first access
        if not self._pv_map:
            for attr_name in dir(self):
                if attr_name.startswith('_'):
                    continue
                try:
                    attr = getattr(self, attr_name, None)
                    if hasattr(attr, 'pvname'):
                        self._pv_map[attr.pvname] = attr
                except Exception:
                    pass

        # Initialize backend with PV definitions
        if self.backend and not self._initialized:
            pv_defs = [
                {{'name': name, 'type': 'float'}}
                for name in self._pv_map.keys()
            ]
            initial_values = self.backend.initialize(pv_defs)

            # Apply initial values
            for pv_name, value in initial_values.items():
                if pv_name in self._pv_map:
                    try:
                        await self._pv_map[pv_name].write(value)
                    except Exception:
                        pass

            self._initialized = True

        # Simulation loop
        heartbeat = 0
        while True:
            await async_lib.library.sleep(self._scan_period)

            # Get updates from backend
            if self.backend:
                updates = self.backend.step(self._scan_period)
                for pv_name, value in updates.items():
                    if pv_name in self._pv_map:
                        try:
                            await self._pv_map[pv_name].write(value)
                        except Exception:
                            pass

            # Update heartbeat
            heartbeat = (heartbeat + 1) % 1000000
            await instance.write(heartbeat)


# =============================================================================
# SP/RB Pairings
# =============================================================================

PAIRINGS = {pairings_literal}


# =============================================================================
# Main Entry Point
# =============================================================================

def print_startup_info(pv_count: int, port: int):
    """Display server startup information."""
    print("=" * 70)
    print(f"{ioc_name} - EPICS Soft IOC")
    print("=" * 70)
    print(f"\\nEPICS CA Port: {{port}}")
    print(f"PV Count: {{pv_count}}")
    print(f"Backend: {backend_type}")
    print(f"\\nTo test:")
    print(f"  caget SIM:HEARTBEAT")
    print("\\nPress Ctrl+C to stop")
    print("=" * 70)


if __name__ == '__main__':
    # Parse arguments
    ioc_options, run_options = ioc_arg_parser(
        default_prefix='',
        desc=__doc__
    )

    # Create backend
    backend = {_get_backend_instantiation(backend_type, noise_level)}

    # Create IOC
    ioc = {ioc_class_name}(backend=backend, **ioc_options)

    # Print startup info
    print_startup_info({len(channels)}, {port})

    # Run server
    run(ioc.pvdb, **run_options)
'''
    return ioc_code


def _to_class_name(name: str) -> str:
    """Convert IOC name to class name (PascalCase).

    Args:
        name: IOC name (e.g., 'accelerator_sim')

    Returns:
        Class name (e.g., 'AcceleratorSim')
    """
    # Split on underscores and capitalize each part
    parts = name.replace("-", "_").split("_")
    return "".join(word.capitalize() for word in parts)


def sanitize_pv_name(pv_name: str) -> str:
    """Convert EPICS PV name to valid Python identifier.

    Args:
        pv_name: Original PV name (e.g., 'MAG:QUAD[Q01]:CURRENT:SP')

    Returns:
        Valid Python identifier (e.g., 'MAG_QUAD_Q01_CURRENT_SP')
    """
    # Replace invalid characters with underscore
    sanitized = re.sub(r"[:\[\]\-\.]", "_", pv_name)

    # Collapse multiple underscores
    sanitized = re.sub(r"_+", "_", sanitized)

    # Strip leading/trailing underscores
    sanitized = sanitized.strip("_")

    # Prefix with 'pv_' if starts with digit
    if sanitized and sanitized[0].isdigit():
        sanitized = "pv_" + sanitized

    # Ensure non-empty
    if not sanitized:
        sanitized = "pv_unnamed"

    return sanitized


def _generate_pv_definitions(channels: list[dict]) -> str:
    """Generate PV property definitions for all channels.

    Args:
        channels: List of PV definitions

    Returns:
        Python code string for PV definitions
    """
    lines = []
    seen_names = set()

    for pv in channels:
        pv_name = pv["name"]
        python_name = pv.get("python_name", sanitize_pv_name(pv_name))

        # Handle name collisions
        original_name = python_name
        counter = 1
        while python_name in seen_names:
            python_name = f"{original_name}_{counter}"
            counter += 1
        seen_names.add(python_name)

        pv_type = pv.get("type", "float")
        read_only = pv.get("read_only", False)
        description = pv.get("description", "")[:80]  # Truncate long descriptions
        # Escape quotes in description
        description = description.replace("'", "\\'")

        if pv_type == "float":
            lines.append(_generate_float_pv(python_name, pv_name, pv, description, read_only))
        elif pv_type == "int":
            lines.append(_generate_int_pv(python_name, pv_name, pv, description, read_only))
        elif pv_type == "enum":
            lines.append(_generate_enum_pv(python_name, pv_name, pv, description, read_only))
        elif pv_type == "string":
            lines.append(_generate_string_pv(python_name, pv_name, description, read_only))
        elif pv_type in ("float_array", "int_array"):
            lines.append(_generate_array_pv(python_name, pv_name, pv, description, read_only))
        else:
            # Default to float
            lines.append(_generate_float_pv(python_name, pv_name, pv, description, read_only))

    return "\n".join(lines)


def _generate_float_pv(
    python_name: str,
    epics_name: str,
    pv: dict,
    description: str,
    read_only: bool,
) -> str:
    """Generate a float PV property."""
    units = pv.get("units", "")
    precision = pv.get("precision", 4)
    high_alarm = pv.get("high_alarm", 100.0)
    low_alarm = pv.get("low_alarm", 0.0)

    return f"""    {python_name} = pvproperty(
        name='{epics_name}',
        value=0.0,
        precision={precision},
        units='{units}',
        upper_alarm_limit={high_alarm},
        lower_alarm_limit={low_alarm},
        read_only={read_only},
        doc='{description}'
    )
"""


def _generate_int_pv(
    python_name: str,
    epics_name: str,
    pv: dict,
    description: str,
    read_only: bool,
) -> str:
    """Generate an integer PV property."""
    units = pv.get("units", "")

    return f"""    {python_name} = pvproperty(
        name='{epics_name}',
        value=0,
        units='{units}',
        read_only={read_only},
        doc='{description}'
    )
"""


def _generate_enum_pv(
    python_name: str,
    epics_name: str,
    pv: dict,
    description: str,
    read_only: bool,
) -> str:
    """Generate an enum PV property."""
    enum_strings = pv.get("enum_strings", ["Off", "On"])

    return f"""    {python_name} = pvproperty(
        name='{epics_name}',
        value=0,
        dtype=ChannelType.ENUM,
        enum_strings={enum_strings},
        read_only={read_only},
        doc='{description}'
    )
"""


def _generate_string_pv(
    python_name: str,
    epics_name: str,
    description: str,
    read_only: bool,
) -> str:
    """Generate a string PV property."""
    return f"""    {python_name} = pvproperty(
        name='{epics_name}',
        value='',
        max_length=256,
        read_only={read_only},
        doc='{description}'
    )
"""


def _generate_array_pv(
    python_name: str,
    epics_name: str,
    pv: dict,
    description: str,
    read_only: bool,
) -> str:
    """Generate an array PV property."""
    count = pv.get("count", 128)

    return f"""    {python_name} = pvproperty(
        name='{epics_name}',
        value=[0.0] * {count},
        read_only={read_only},
        doc='{description}'
    )
"""


def _generate_pairings_literal(pairings: dict[str, str]) -> str:
    """Generate Python dict literal for pairings.

    Args:
        pairings: Dict mapping setpoint to readback PV names

    Returns:
        Python dict literal string
    """
    if not pairings:
        return "{}"

    lines = ["{"]
    for sp, rb in pairings.items():
        lines.append(f"    '{sp}': '{rb}',")
    lines.append("}")
    return "\n".join(lines)


def _generate_backend_code(
    backend_type: str,
    pairings: dict[str, str],
    noise_level: float,
    update_rate: float,
) -> str:
    """Generate embedded simulation backend code.

    Args:
        backend_type: 'passthrough' or 'mock_style'
        pairings: SP->RB pairings dict
        noise_level: Noise level for SP->RB tracking
        update_rate: Simulation update rate in Hz

    Returns:
        Python code string for backend class
    """
    if backend_type == "passthrough":
        return _generate_passthrough_backend()
    else:
        return _generate_mock_style_backend(noise_level)


def _generate_passthrough_backend() -> str:
    """Generate passthrough (no-op) backend code."""
    return '''class PassthroughBackend:
    """No-op backend that just stores values.

    PVs retain their written values but no physics simulation occurs.
    """

    def initialize(self, pv_definitions: list[dict]) -> dict[str, Any]:
        """Initialize - no special setup needed."""
        return {}

    def on_write(self, pv_name: str, value: Any) -> dict[str, Any]:
        """Handle write - no updates to other PVs."""
        return {}

    def step(self, dt: float) -> dict[str, Any]:
        """Step - no time evolution."""
        return {}
'''


def _generate_mock_style_backend(noise_level: float) -> str:
    """Generate mock-style archiver backend code."""
    return f'''class MockStyleBackend:
    """Archiver-style simulation with hardcoded PV-type behaviors.

    This backend replicates the mock archiver connector's value generation logic.
    PV behaviors are determined by keyword matching on PV names.

    Supported behaviors:
    - BPM/position: Random equilibrium offset + slow drift + noise
    - Beam current: 500 mA base with decay
    - Current: 150 mA base with linear trend
    - Voltage: 5000 V base, stable with small oscillation
    - Pressure: 1e-9 Torr base with gradual increase
    - Temperature: 25 C base with gradual increase
    - Lifetime: 10 hours base, decreasing trend
    - Default: 100.0 base with linear trend
    """

    def __init__(self, noise_level: float = {noise_level}):
        """Initialize backend.

        Args:
            noise_level: Default noise level for SP->RB tracking (0.01 = 1%)
        """
        self.noise_level = noise_level
        self._state: dict[str, float] = {{}}
        self._rng_per_pv: dict[str, np.random.Generator] = {{}}

    def initialize(self, pv_definitions: list[dict]) -> dict[str, float]:
        """Initialize all PVs with type-appropriate values."""
        initial_values = {{}}

        for pv in pv_definitions:
            name = pv['name']

            # Create reproducible RNG for this PV
            seed = hash(name) % (2**32)
            self._rng_per_pv[name] = np.random.default_rng(seed=seed)

            # Generate initial value based on PV name keywords
            value = self._get_initial_value(name)
            self._state[name] = value
            initial_values[name] = value

        return initial_values

    def _get_initial_value(self, pv_name: str) -> float:
        """Get initial value based on PV name keywords (hardcoded heuristics)."""
        name = pv_name.lower()
        rng = self._rng_per_pv.get(pv_name)

        # BPM positions: random offset around zero
        if 'bpm' in name or 'position' in name:
            return float(rng.uniform(-0.1, 0.1)) if rng else 0.0

        # Beam current (DCCT): 500 mA
        if 'beam' in name and 'current' in name:
            return 500.0
        if 'dcct' in name:
            return 500.0

        # Other currents: 150 mA
        if 'current' in name:
            return 150.0

        # Voltages: 5000 V
        if 'voltage' in name:
            return 5000.0

        # Pressures: 1e-9 Torr (vacuum)
        if 'pressure' in name:
            return 1e-9

        # Temperatures: 25 C
        if 'temp' in name:
            return 25.0

        # Lifetime: 10 hours
        if 'lifetime' in name:
            return 10.0

        # Default
        return 100.0

    def on_write(self, pv_name: str, value: float) -> dict[str, float]:
        """Handle setpoint write, update paired readback."""
        updates = {{}}
        self._state[pv_name] = value

        # Check explicit pairings
        if pv_name in PAIRINGS:
            rb_name = PAIRINGS[pv_name]

            # Apply noise
            if self.noise_level > 0 and value != 0:
                noisy = value + random.gauss(0, abs(value) * self.noise_level)
            else:
                noisy = value

            self._state[rb_name] = noisy
            updates[rb_name] = noisy

        return updates

    def step(self, dt: float) -> dict[str, float]:
        """Advance simulation by dt seconds (hardcoded behaviors)."""
        updates = {{}}

        for pv_name, current in list(self._state.items()):
            name = pv_name.lower()
            rng = self._rng_per_pv.get(pv_name)

            # BPM positions: slow drift + noise
            if 'bpm' in name or 'position' in name:
                if rng:
                    drift = float(rng.normal(0, 0.001 * dt))
                    noise = float(rng.normal(0, 0.001))
                    new_value = current + drift + noise
                    # Mean reversion toward zero
                    new_value -= 0.01 * current * dt
                    self._state[pv_name] = new_value
                    updates[pv_name] = new_value

            # Beam current: slow decay
            elif ('beam' in name and 'current' in name) or 'dcct' in name:
                # ~5% decay per hour
                decay = current * 0.00001 * dt
                new_value = current - decay
                if rng:
                    new_value += float(rng.normal(0, 0.5))
                self._state[pv_name] = new_value
                updates[pv_name] = new_value

            # Pressures: slight increase over time
            elif 'pressure' in name:
                increase = current * 0.0001 * dt
                new_value = current + increase
                if rng:
                    new_value *= (1 + float(rng.normal(0, 0.01)))
                self._state[pv_name] = new_value
                updates[pv_name] = new_value

            # Temperatures: gradual increase
            elif 'temp' in name:
                increase = 0.001 * dt
                new_value = current + increase
                if rng:
                    new_value += float(rng.normal(0, 0.1))
                self._state[pv_name] = new_value
                updates[pv_name] = new_value

        return updates
'''


def _get_backend_instantiation(backend_type: str, noise_level: float) -> str:
    """Get backend class instantiation code.

    Args:
        backend_type: 'passthrough' or 'mock_style'
        noise_level: Noise level for mock_style backend

    Returns:
        Python code string for instantiating backend
    """
    if backend_type == "passthrough":
        return "PassthroughBackend()"
    else:
        return f"MockStyleBackend(noise_level={noise_level})"


def write_soft_ioc_file(
    output_path: Path,
    config: dict,
    channels: list[dict],
    pairings: dict[str, str],
) -> Path:
    """Generate and write soft IOC file.

    Args:
        output_path: Where to write the IOC file
        config: Simulation configuration
        channels: List of PV definitions
        pairings: SP->RB pairings

    Returns:
        Path to written file
    """
    code = generate_soft_ioc(config, channels, pairings)

    output_path.parent.mkdir(parents=True, exist_ok=True)
    output_path.write_text(code, encoding="utf-8")
    output_path.chmod(0o755)  # Make executable

    return output_path
